<?xml version='1.0' encoding='iso-8859-1' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd" [ 
  <!ENTITY nbsp "&#160;">
] >

<issue num="2010" status="Open">
<title><tt>is_* traits</tt> for binding operations can't be meaningfully specialized</title>
<section><sref ref="[func.bind.isbind]"/></section>
<submitter>Sean Hunt</submitter>
<date>19 Jul 2010</date>

<discussion>
<p>
<sref ref="[func.bind.isbind]"/> says for <tt>is_bind_expression</tt>:
</p>

<blockquote><p>
Users may specialize this template to indicate that a type should be
treated as a subexpression in a <tt>bind</tt> call.
</p></blockquote>

<p>
But it also says:
</p>

<blockquote><p>
If <tt>T</tt> is a type returned from <tt>bind</tt>,
<tt>is_bind_expression&lt;T&gt;</tt> shall be publicly derived from
<tt>integral_constant&lt;bool, true&gt;</tt>, otherwise from
<tt>integral_constant&lt;bool, false&gt;</tt>.
</p></blockquote>

<p>
This means that while the user is free to specialize, any specialization
would have to be <tt>false</tt> to avoid violating the second
requirement. A similar problem exists for <tt>is_placeholder</tt>.
</p>
</discussion>

<note>
2010 Batavia (post meeting session)
</note>
<p>
Alisdair recognises this is clearly a bug introduced by some wording he
wrote, the sole purpose of this metafunction is as a customization point
for users to write their own <tt>bind</tt>-expression types that participate
in the standard library <tt>bind</tt> protocol.  The consensus was that this
should be fixed in Madrid, moved to Open.
</p>

<note>2011-05-13 Jonathan Wakely comments and provides proposed wording</note>

<p>
The requirements are that <tt>is_bind_expression&lt;T&gt;::value</tt> is true when <tt>T</tt>
is a type returned from <tt>bind</tt>, false for any other type, except when
there's a specialization involving a user-defined type (N.B. <sref ref="[namespace.std]"/> 
means we don't need to say e.g. <tt>is_bind_expression&lt;string&gt;</tt> is false.)
<p/>
The obvious way to meet the requirements is for the primary template
to derive from <tt>integral_constant&lt;bool, false&gt;</tt> and for implementations
to provide specializations for the unspecified types returned from
<tt>bind</tt>.  User-defined specializations can do whatever they like, as long
as <tt>is_bind_expression::value</tt> is sane. There's no reason to forbid
users from defining <tt>is_bind_expression&lt;<i>user_defined_type</i>&gt;::value=false</tt>
if that's what they want to do.
<p/>
Similar reasoning applies to <tt>is_placeholder</tt>, but a further issue is
that <sref ref="[func.bind.isbind]"/> contains wording for <tt>is_placeholder</tt> but
contains no definition of it and the sub-clause name only refers to
<tt>is_bind_expression</tt>. The wording below proposes splitting paragraphs 3
and 4 of <sref ref="[func.bind.isbind]"/> into a new sub-clause covering
<tt>is_placeholder</tt>.
<p/>
If the template specializations added by the proposed wording are too
vague then they could be preceded by "for exposition only" comments
</p>

<note>2011-05-18 Daniel comments and provides some refinements to the P&#47;R</note>

<p>
Both <tt>bind</tt>-related type traits should take advantage of the
UnaryTypeTrait requirements. Additionally, the updated wording does not
imply that the implementation provides several specializations. Wording was 
used similar to the specification of the <tt>uses_allocator</tt> type trait 
(which unfortunately is not expressed in terms of BinaryTypeTrait requirements).
</p>

<resolution>
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>Change <sref ref="[func.bind.isbind]"/> to:</p>

<blockquote><pre>
namespace std {
  template&lt;class T&gt; struct is_bind_expression<ins>; <i>// see below</i></ins>
    <del>: integral_constant&lt;bool, <i>see below</i>&gt; { };</del>
}
</pre><blockquote><p>
-1- <tt>is_bind_expression</tt> can be used to detect function objects generated by <tt>bind</tt>. <tt>bind</tt> 
uses <tt>is_bind_expression</tt> to detect subexpressions. <del>Users may specialize this template to indicate 
that a type should be treated as a subexpression in a <tt>bind</tt> call.</del>
<p/>
-2- <del>If <tt>T</tt> is a type returned from <tt>bind</tt>, <tt>is_bind_expression&lt;T&gt;</tt> shall 
be publicly derived from <tt>integral_constant&lt;bool, true&gt;</tt>, otherwise from 
<tt>integral_constant&lt;bool, false&gt;</tt></del><ins>Instantiations of the <tt>is_bind_expression</tt> template
shall meet the UnaryTypeTrait requirements ([meta.rqmts]). The implementation shall provide a definition
that has a BaseCharacteristic of <tt>true_type</tt> if <tt>T</tt> is a type returned from <tt>bind</tt>, otherwise 
it shall have a BaseCharacteristic of <tt>false_type</tt>. A program may specialize this template for a user-defined 
type <tt>T</tt> to have a BaseCharacteristic of <tt>true_type</tt> to indicate that <tt>T</tt> should be treated 
as a subexpression in a <tt>bind</tt> call.</ins>.
<p/>
<del>-3- <tt>is_placeholder</tt> can be used to detect the standard placeholders <tt>_1</tt>, <tt>_2</tt>, and so on. 
<tt>bind</tt> uses <tt>is_placeholder</tt> to detect placeholders. Users may specialize this template to indicate 
a placeholder type.</del>
<p/>
<del>-4- If <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, <tt>is_placeholder&lt;T&gt;</tt> shall be 
publicly derived from <tt>integral_constant&lt;int, J&gt;</tt>, otherwise from <tt>integral_constant&lt;int, 0&gt;</tt>.</del>
</p></blockquote></blockquote>
</li>
<li><p>Insert a new sub-clause immediately following sub-clause <sref ref="[func.bind.isbind]"/>, the suggested
sub-clause tag is [func.bind.isplace]:
</p>
<h3><ins>20.8.9.1.?  Class template <tt>is_placeholder</tt>  [func.bind.isplace]</ins></h3> 
<blockquote><pre>
<ins>namespace std {
  template&lt;class T&gt; struct is_placeholder; <i>// see below</i>
}</ins>
</pre><blockquote><p>
<ins>-?- <tt>is_placeholder</tt> can be used to detect the standard placeholders <tt>_1</tt>, <tt>_2</tt>, and so on. 
<tt>bind</tt> uses <tt>is_placeholder</tt> to detect placeholders.</ins>
<p/>
<ins>-?- Instantiations of the <tt>is_placeholder</tt> template shall meet the UnaryTypeTrait requirements ([meta.rqmts]). 
The implementation shall provide a definition that has a BaseCharacteristic of <tt>integral_constant&lt;int, J&gt;</tt> 
if <tt>T</tt> is the type of <tt>std::placeholders::_J</tt>, otherwise it shall have a BaseCharacteristic of 
<tt>integral_constant&lt;int, 0&gt;</tt>. A program may specialize this template for a user-defined type <tt>T</tt> 
to have a BaseCharacteristic of <tt>integral_constant&lt;int, <i>N</i>&gt;</tt> with <tt><i>N</i> &gt; 0</tt> 
to indicate that <tt>T</tt> should be treated as a placeholder type.</ins>
</p></blockquote></blockquote>
</li>
</ol>
</resolution>

</issue>
