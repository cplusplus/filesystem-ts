<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>

  Draft Filesystem Technical Specification
  </title>
<style type="text/css">

body  { max-width : 7.5in; }
pre    { background-color:#D7EEFF }
a       { text-decoration: none}
a:link {COLOR: #2020FF;}
a:visited {COLOR: #2020FF;}
a:hover {COLOR: #FF2020;}
a:active {COLOR: #009933;}
ins     { background-color:#E8FFE8 }
del     { background-color:#FFD7D7 }
</style>
</head>

<body>
<p>
  <table border="0">
    <tr>
      <td>Document number:&nbsp;&nbsp; </td>
      <td><span style="background-color: #FFFF00">DXXXX</span></td>
    </tr>
    <tr>
      <td>Date:</td>
      <td>
      <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2014-06-21<!--webbot bot="Timestamp" endspan i-checksum="12378" --></td>
    </tr>
    <tr>
      <td>Revises:</td>
      <td>
      N3940</td>
    </tr>
    <tr>
      <td>
      <p>Project:</td>
      <td>
      <p>Programming Language C++</td>
    </tr>
    <tr>
      <td valign="top">
      <p>Project number:</td>
      <td>
      <p>TS 18822</td>
    </tr>
    <tr>
      <td valign="top">
      <p>Reply-to:</td>
      <td>
      <p>Beman Dawes &lt;bdawes at acm dot org&gt;</td>
    </tr>
  </table>

<!-- generate-section-numbers=false -->

<h1 align="center">Working Draft,<br>
Technical Specification &mdash; File System</h1>


<p>© ISO/IEC</p>


<p><i><span style="background-color: #E0E0E0">Gray-shaded italic text is 
editorial commentary on the draft. It will be removed from the actual Technical 
Specification document.</span></i></p>


<h2> <a name="TOC">Contents</a></h2>

<blockquote>
      <p>      <a href="#TOC"> Contents</a><br>
      <a href="#Foreword">Foreword</a><br>
      <a href="#Introduction">Introduction</a><br>
      <a href="#Scope">1  Scope&nbsp; </a><br>
      <a href="#Conformance">2  Conformance </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.conform.9945">2.1  POSIX conformance </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.conform.os">2.2  Operating system dependent behavior conformance </a><br>
      <a href="#Normative-references">3  Normative references&nbsp; </a><br>
      <a href="#Definitions">4  Terms and definitions </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Absolute-path">4.1  absolute path </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#canonical-path">4.2  canonical path </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#directory">4.3  directory </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#file">4.4  file </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#file-system">4.5  file system </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#file-system-race">4.6  file system race </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#filename">4.7  filename </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#hard-link">4.8  hard link </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#link">4.9  link </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.def.native.encode">4.10  native encoding </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.def.native">4.11  native pathname format </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#NTCTS">4.12  NTCTS </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#operating system dependent">4.13  operating system dependent behavior 
</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.def.parent">4.14  parent directory </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#path">4.15  path </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.def.pathname">4.16  pathname </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.def.pathres">4.17  pathname resolution </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Relative-path">4.18  relative path </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#symbolic-link">4.19  symbolic link </a><br>
      <a href="#fs.req">5  Requirements</a><br>
&nbsp;&nbsp; <a href="#Namespaces-and-headers">5.1 Namespaces and headers</a><a href="#fs.req"> </a><br>
      <a href="#Header-filesystem-synopsis">6  Header <code>&lt;experimental/filesystem&gt;</code> synopsis 
</a><br>
      <a href="#Error-reporting">7  Error reporting </a><br>
      <a href="#class-path">8  Class <code>path</code> </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#path.generic">8.1  <code>path</code> generic pathname format grammar </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#path-Conversions">8.2  <code>path</code> conversions </a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-Conversions-to-native-format">8.2.1  <code>path</code> argument format 
conversions </a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path.arg.convert">8.2.2  <code>path</code> type and encoding conversions </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#path-Requirements">8.3  <code>path</code> requirements </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#path.member">8.4  <code>path</code> members&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-constructors">8.4.1   <code>path</code> constructors </a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-assignments">8.4.2  <code>path</code> assignments </a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-appends">8.4.3  <code>path</code> appends 
</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-concatenation">8.4.4  <code>path</code> concatenation </a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-modifiers">8.4.5   <code>path</code> modifiers </a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-native-format-observers">8.4.6  <code>path</code> native format observers 
</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-generic-format-observers">8.4.7  <code>path</code> generic format observers 
</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-compare">8.4.8  <code>path</code> compare </a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-decomposition">8.4.9   <code>path</code> decomposition 
</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-query">8.4.10   <code>path</code> query </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#path-iterators">8.5   <code>path</code> iterators </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#path-non-member-functions">8.6   <code>path</code> non-member functions 
</a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path-inserter-extractor">8.6.1  <code>path</code> inserter and extractor </a><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#path.factory">8.6.2  <code>path</code> factory functions </a><br>
      <a href="#Class-filesystem_error">9  Class <code>filesystem_error</code> 
</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#filesystem_error-members">9.1   <code>filesystem_error</code> members 
</a><br>
      <a href="#fs.enum">10  Enumerations&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#Enum-file_type">10.1  Enum class <code>file_type</code> </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#enum.copy_options">10.2  Enum class <code>copy_options</code> </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#enum.perms">10.3  Enum class <code>perms</code> </a><br>
      <a href="#file_status">11  Class <code>file_status</code> </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#file_status-constructors">11.1  <code>file_status</code> constructors 
</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#file_status-observers">11.2  <code>file_status</code> observers </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#file_status-modifiers">11.3  <code>file_status</code> modifiers </a><br>
      <a href="#Class-directory_entry">12  Class <code>directory_entry</code> </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#directory_entry-constructors">12.1  <code>directory_entry</code> constructors 
</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#directory_entry-modifiers">12.2  <code>directory_entry</code> modifiers 
</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#directory_entry-observers">12.3  <code>directory_entry</code> observers 
</a><br>
      <a href="#Class-directory_iterator">13  Class <code>directory_iterator</code> 
</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#directory_iterator-members">13.1  <code>directory_iterator</code> members 
</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#directory_iterator-non-member-functions">13.2  <code>directory_iterator</code> non-member functions 
</a><br>
      <a href="#Class-recursive_directory_iterator">14  Class <code>recursive_directory_iterator</code> 
</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#recursive_directory_iterator-members">14.1  <code>recursive_directory_iterator</code> members 
</a><br>
      &nbsp;&nbsp;&nbsp;<a href="#rec.dir.itr.nonmembers">14.2  <code>recursive_directory_iterator</code> non-member functions 
</a><br>
      <a href="#Operational-functions">15  Operational functions </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.absolute">15.1  Absolute&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.canonical">15.2  Canonical&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.copy">15.3  Copy&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.copy_file">15.4  Copy file&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.copy_symlink">15.5  Copy symlink&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.create_directories">15.6  Create directories&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.create_directory">15.7  Create directory&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.create_dir_symlk">15.8  Create directory symlink&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.create_hard_lk">15.9  Create hard link&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.create_symlink">15.10  Create symlink&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.current_path">15.11  Current path&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.exists">15.12  Exists&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.equivalent">15.13  Equivalent&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.file_size">15.14  File size&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.hard_lk_ct">15.15  Hard link count&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.is_block_file">15.16  Is block file&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.is_char_file">15.17  Is character file&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.is_directory">15.18  Is directory&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.is_empty">15.19  Is empty&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.is_fifo">15.20  Is fifo&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.is_other">15.21  Is other&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.is_regular_file">15.22  Is regular file&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.is_socket">15.23  Is socket&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.is_symlink">15.24  Is symlink&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.last_write_time">15.25  Last write time&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.permissions">15.26  Permissions&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.read_symlink">15.27  Read symlink&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.remove">15.28  Remove&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.remove_all">15.29  Remove all&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.rename">15.30  Rename&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.resize_file">15.31  Resize file&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.space">15.32  Space&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.status">15.33  Status&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.status_known">15.34  Status known&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.symlink_status">15.35  Symlink status&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.system_complete">15.36  System complete&nbsp; </a><br>
      &nbsp;&nbsp;&nbsp;<a href="#fs.op.temp_dir_path">15.37 Temporary directory 
      path</a></p>
</blockquote>
      
<hr>
<h2><a name="Foreword">Foreword</a></h2>

<p><span style="background-color: #E0E0E0"><i>ISO requires a foreword, with most 
content supplied by the Central Secretariat of ISO. It will be added by the 
editor before the final document is sent to ISO.</i></span></p>

<h2><a name="Introduction">Introduction</a></h2>

<p><span style="background-color: #E0E0E0"><i>ISO specifies &quot;The introduction is 
an optional preliminary element used, if required, to give specific information 
or commentary about the technical content of the document, and about the reasons 
prompting its preparation. It shall not contain requirements.&quot;</i></span></p>

<!-- generate-section-numbers=true -->


<h2>1  <a name="Scope">Scope</a>&nbsp; [fs.scope]</h2>

<p>This Technical Specification specifies requirements for implementations of an 
interface that computer programs written in the C++ programming language may use 
to perform operations on file systems and their components, such as paths, 
regular files, and directories. This Technical Specification is applicable to 
information technology systems that can access hierarchical file systems, such 
as those with operating systems that conform to the POSIX ([fs.norm.ref]) 
interface. This Technical Specification is applicable only to vendors who wish 
to provide the interface it describes.</p>

<h2>2  <a name="Conformance">Conformance</a> [fs.conformance]</h2>

<p>Conformance is specified in terms of behavior. Ideal behavior is not always 
implementable, so the conformance sub-clauses take that into account.</p>

<h3>2.1  POSIX conformance [<a name="fs.conform.9945">fs.conform.9945</a>]</h3>
<p>Some behavior is specified by reference to POSIX ([fs.norm.ref]). How such behavior is actually implemented is unspecified.</p>
<blockquote>
<p>[<i>Note:</i> This constitutes an &quot;as if&quot; rule allowing implementations 
to call native 
operating system or other API's. <i>&mdash;end note</i>]</p>
</blockquote>
<p>Implementations are encouraged to provide such behavior as it is defined by 
POSIX. Implementations shall document any behavior that differs from the 
behavior defined by POSIX. Implementations that do not support exact POSIX 
behavior are encouraged to provide behavior as close to POSIX behavior as is reasonable given the 
limitations of actual operating systems and file systems. If an implementation cannot provide any 
reasonable behavior, the implementation shall report an error as specified in § 7 [fs.err.report].
</p>
<blockquote>
<p>[<i>Note:</i> This allows users to rely on an exception being thrown or 
an error code being set when an implementation cannot provide any reasonable 
behavior. — <i>end note</i>]</p>
</blockquote>
<p>Implementations are not required to provide behavior that is not supported by 
a particular file system.</p>
<blockquote>
<p>[<i>Example:</i> The <a href="http://en.wikipedia.org/wiki/FAT_filesystem">
FAT file system</a> used by some memory cards, camera memory, and floppy discs 
does not support hard links, symlinks, and many other features of more capable 
file systems, so implementations are not required to support those features 
on the FAT file system. <i>&mdash;end example</i>]</p>
</blockquote>
<p>The behavior of functions described in this 
Technical Specification 
may differ from their specification in 
the presence of <a href="#file-system-race">file system races</a> ([fs.def.race]). No diagnostic is required.</p>
<p>If the possibility of a file system race would make it unreliable for a program to 
test for a precondition before calling a function described herein, <i>
Requires</i> is not specified for the function.</p>
<blockquote>
<p>[<i>Note:</i> As a design practice, preconditions are not specified when it 
is unreasonable for a program to detect them prior to calling the function. <i>
&mdash;end note</i>]</p>
</blockquote>
<h3>2.2  Operating system dependent behavior conformance [<a name="fs.conform.os">fs.conform.os</a>]</h3>
<p>Some behavior is specified as being 
operating system dependent ([fs.def.osdep]). The operating system an 
implementation is dependent upon is implementation defined.</p>
<p>It is permissible for an implementation to be dependent upon an operating 
system emulator rather than the actual underlying operating system.</p>

<h2>3  <a name="Normative-references">Normative references</a>&nbsp; [fs.norm.ref]</h2>

<p>The following referenced documents are indispensable for the application of 
this document. For dated references, only the edition cited applies. For undated 
references, the latest edition of the referenced document (including any 
amendments) applies. <span style="background-color: #E0E0E0"><i>ISO required 
wording.</i></span></p>

<ul>
  <li>ISO/IEC 14882, <i>Programming Language C++<br>
&nbsp;</i></li>
  <li>ISO/IEC 9945, <i>Information Technology — Portable Operating System 
  Interface (POSIX)</i></li>
</ul>

<p>[<i>Note:</i> The programming language and library described in ISO/IEC 14882 
is herein called <i>the C++ Standard</i>. References to clauses within the C++ 
Standard are written as &quot;C++11 §3.2&quot;.<p>The operating system interface 
described in ISO/IEC 9945 is herein called <i>POSIX</i>. <i>&mdash;end note</i>]<p>This 
Technical Specification  mentions commercially 
available operating systems for purposes of exposition.<sup> <a href="#footnote">
[footnote]</a></sup><p>Unless otherwise specified, the whole of the C++ 
Standard&#39;s Library introduction (C++11 §17) is included into this Technical 
Specification by reference.<p><i><span style="background-color: #E0E0E0">This footnote 
is required by ISO/IEC Directives, Part2, section 6.6.3 Use of trade names and 
trademarks:</span></i><blockquote>
  <p><sup>[<a name="footnote">footnote</a>]</sup> POSIX® is 
a registered trademark of The IEEE. MAC OS® is a registered trademark of Apple 
Inc. Windows® is a registered trademark of Microsoft Corporation. This information is given for the convenience of 
users of this document and does not constitute an endorsement by ISO or IEC of 
these products.</blockquote>
<p></p>

<h2>4  <a name="Definitions">Terms and definitions</a> [fs.definitions]</h2>
<p>For the purposes of this document, the terms and definitions given in the C++ 
Standard and the following apply.</p>

<h3>4.1  <a name="Absolute-path">absolute path</a> [fs.def.absolute-path]</h3>
<p>A path that 
unambiguously 
identifies the location of a file without reference to an additional starting 
location. The elements of a path that determine if it is absolute are 
operating system dependent.</p>

<h3>4.2  <a name="canonical-path">canonical path</a> [fs.def.cannonical-path]</h3>
<p>An absolute path that has 
no elements that are symbolic links, and no dot or dot-dot elements ([<a href="#path.generic">path.generic</a>]).</p>
<h3>4.3  <a name="directory">directory</a> [fs.def.directory]</h3>
<p>A file within a file system that acts as a container of directory entries 
that contain information about 
other files, possibly including other directory files.</p>
<h3>4.4  <a name="file">file</a> [fs.def.file]</h3>
<p>An object within a file system that holds user or system data. Files can be written to, or read from, or both. A file 
has certain attributes, including type. File types include regular files 
and directories. Other types of files, such as symbolic links, may be supported by the 
implementation.</p>
<h3>4.5  <a name="file-system">file system</a> [fs.def.filesystem]</h3>
<p>A collection of files and certain of their attributes.</p>
<h3>4.6  <a name="file-system-race">file system race</a> [fs.def.race]</h3>
<p>The condition that occurs 
when multiple threads, processes, or computers interleave access and 
modification of 
the same object within a file system.</p>

<h3>4.7  <a name="filename">filename</a> [fs.def.filename]</h3>
  <p>The name of a file. Filenames dot&nbsp; 
and dot-dot&nbsp; have special meaning. The following characteristics of 
  filenames are operating system dependent:</p>
<ul>
  <li>
  <p>The permitted characters. [<i>Example</i>: Some operating systems prohibit the ASCII control characters (0x00-0x1F) 
    in filenames. <i>&mdash;end example</i>].</p>
  </li>
  <li>The maximum permitted length.</li>
  <li>
  <p>Filenames that are not permitted.</p>
  </li>
  <li>
  <p>Filenames that have special meaning.</p>
  </li>
  <li>
  <p>Case awareness and sensitivity during path resolution.</p>
  </li>
  <li>
  <p>Special rules that may apply to file types other than regular 
  files, such as directories.</p>
  </li>
</ul>
<h3>4.8  <a name="hard-link">hard link</a> [fs.def.hardlink]</h3>
<p>A link ([fs.def.link]) to an existing file. Some 
file systems support multiple hard links to a file. If the last hard link to a 
file is removed, the file itself is removed.</p>
<blockquote>
<p>[<i>Note:</i> A hard link can be thought of as a shared-ownership smart 
pointer to a file.<i> &mdash;end note</i>]<i> </i></p>
</blockquote>
<h3>4.9  <a name="link">link</a> [fs.def.link]</h3>
<p>A directory entry object that associates a 
filename with a file. A link is either a hard link ([fs.def.hardlink]) or a 
symbolic link ([fs.def.symlink]).</p>

<h3>4.10  native encoding [<a name="fs.def.native.encode">fs.def.native.encode</a>]</h3>
<p>For narrow character strings, the operating system dependent current encoding 
for path names. For wide character strings, the implementation defined execution 
wide-character set encoding (C++11 §2.3).</p>

<h3>4.11  native pathname format [<a name="fs.def.native">fs.def.native</a>]</h3>
<p>The operating system dependent pathname format accepted by the host operating system.</p>
<h3>4.12  <a name="NTCTS">NTCTS</a> [<a name="fs.def.ntcts">fs.def.ntcts</a>]</h3>
<p>Acronym for &quot;null-terminated character-type sequence&quot;. Describes a sequence 
of values of a given encoded character type terminated by that type's null character. If 
the encoded character type is <code>charT</code>, the null character can be constructed 
by <code>charT()</code>. <span style="background-color: #E0E0E0"><i>This is an 
expansion of the definition in chapter 17; that definition is very hard to 
parse. A request for clarification has been sent to the C++ standard project editor.</i></span></p>
<h3>4.13  <a name="operating system dependent">operating system dependent</a> behavior 
[fs.def.osdep]</h3>
<p>Behavior  that is dependent upon the behavior 
and characteristics of an operating system. See [fs.conform.os].</p>
<h3>4.14  parent directory [<a name="fs.def.parent">fs.def.parent</a>]</h3>
<p>When discussing a given directory, the directory that both contains a 
directory entry for the given directory and is represented by the pathname 
dot-dot in the given directory.</p>
<p>When discussing other types of files, a directory containing a directory 
entry for the file under discussion.</p>
<p>This concept does not apply to dot and dot-dot.</p>
<h3>4.15  <a name="path">path</a> [fs.def.path]</h3>
<p>A sequence of elements that identify 
the location of a file within a filesystem. The elements are the <i>root-name<sub>opt</sub></i>, <i>
root-directory<sub>opt</sub></i>, and an optional sequence of filenames. 
The maximum number of elements in the sequence is operating system dependent.
</p>

<h3>4.16  pathname [<a name="fs.def.pathname">fs.def.pathname</a>]</h3>
<p>A character string that represents 
the name of a 
path. Pathnames are formatted according to the generic pathname format grammar 
([<a href="#path.generic">path.generic</a>]) or an 
operating system dependent 
native pathname format.</p>

<h3>4.17  pathname resolution [<a name="fs.def.pathres">fs.def.pathres</a>]</h3>

<p>Pathname resolution is the operating system dependent mechanism for resolving 
a pathname to a particular file in a file hierarchy. There may be multiple 
pathnames that resolve to the same file.&nbsp; [<i>Example:</i> POSIX specifies the mechanism in section 4.11, Pathname resolution. <i>
&mdash;end example]</i></p>

<h3>4.18  <a name="Relative-path">relative path</a> [fs.def.relative-path]</h3>
<p>A path that 
is not absolute, and so only 
unambiguously 
identifies the location of a file when resolved relative to 
an implied starting location. The elements of a path that determine if it is 
relative are operating system dependent.&nbsp; [<i>Note:</i> 
Paths <code>&quot;.&quot;</code> and <code>&quot;..&quot;</code> are relative paths. <i>&mdash;end note</i>]</p>
<h3>4.19  <a name="symbolic-link">symbolic link</a> [fs.def.symlink]</h3>
<p>A link ([fs.def.link]) with the 
property that when the file is encountered during pathname resolution, a string 
stored by the file is used to modify the pathname resolution.</p>
<blockquote>
<p>[<i>Note:</i> Symbolic links are often called symlinks. A symbolic link can be thought of as a raw pointer to a file. 
If the file pointed to does not exist, the symbolic link is said to be a 
&quot;dangling&quot; symbolic link.<i> &mdash;end note</i>]<i> </i></p>
</blockquote>

<h2>5  Requirements [<a name="fs.req">fs.req</a>]</h2>
<p>Throughout this Technical Specification, <code>char</code>, <code>wchar_t</code>,
<code>char16_t</code>, and <code>char32_t</code> are collectively called <i>
encoded character types</i>.</p>

<p>Template parameters named <code>charT</code> shall be one of the 
encoded character types.</p>

<p>Template parameters named <code>InputIterator</code> shall meet the 
C++ Standard&#39;s library input iterator requirements (C++11 §24.2.3) and shall 
have a value type that is one of the encoded character types.</p>

<blockquote>
<p>[<i>Note:</i> Use of an encoded character type implies an associated 
encoding. Since <code>signed char</code> and <code>unsigned char</code> have no 
implied encoding, they are not included as permitted types. <i>&mdash;end note</i>]</p>

</blockquote>
<h3>5.1 <a name="Namespaces-and-headers">Namespaces and headers</a> [fs.req.namespace]</h3>


<p>The components described in this technical specification are experimental and 
not part of the C++ standard library. All components described in this technical 
specification are declared in namespace <code>std::experimental::filesystem::v1</code> 
or a sub-namespace thereof unless otherwise specified. The header described in 
this technical specification shall import the contents of <code>
std::experimental::filesystem::v1</code> into <code>std::experimental::filesystem</code> as 
if by</p>
<blockquote>
<pre>namespace std {
  namespace experimental {
    namespace filesystem {
      inline namespace v1 {}
    }
  }
}</pre>
</blockquote>
<p>Unless otherwise specified, references to other entities described in this 
technical specification are assumed to be qualified with <code>std::experimental::</code><code>filesystem::v1::</code>, 
and references to entities described in the C++ standard are assumed to be qualified 
with <code>std::</code>.</p>

<h2>6  <a name="Header-filesystem-synopsis">Header <code>&lt;experimental/filesystem&gt;</code> synopsis</a> 
[fs.filesystem.synopsis]</h2>
<pre>namespace std { namespace experimental { namespace filesystem { inline namespace v1 {

    class <a href="#class-path">path</a>;
    
    void swap(path&amp; lhs, path&amp; rhs) noexcept;
    size_t <a href="#hash_value">hash_value</a>(const path&amp; p) noexcept;

    bool operator==(const path&amp; lhs, const path&amp; rhs) noexcept;
    bool operator!=(const path&amp; lhs, const path&amp; rhs) noexcept;
    bool operator&lt; (const path&amp; lhs, const path&amp; rhs) noexcept;
    bool operator&lt;=(const path&amp; lhs, const path&amp; rhs) noexcept;
    bool operator&gt; (const path&amp; lhs, const path&amp; rhs) noexcept;
    bool operator&gt;=(const path&amp; lhs, const path&amp; rhs) noexcept;

    path operator/ (const path&amp; lhs, const path&amp; rhs);

    template &lt;class charT, class traits&gt;
    basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const path&amp; p);

    template &lt;class charT, class traits&gt;
    basic_istream&lt;charT, traits&gt;&amp;
    operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, path&amp; p);

    template &lt;class <a href="#Source">Source</a>&gt;  
      path u8path(Source const&amp; source);
    template &lt;class InputIterator&gt;
      path u8path(InputIterator first, InputIterator last);

    class <a href="#Class-filesystem_error">filesystem_error</a>;      
    class <a href="#Class-directory_entry">directory_entry</a>;

    class <a href="#Class-directory_iterator">directory_iterator</a>;

    // enable directory_iterator range-based for statements
    directory_iterator <a href="#directory_iterator-non-member-functions">begin</a>(directory_iterator iter) noexcept;
    directory_iterator <a href="#directory_iterator-non-member-functions">end</a>(const directory_iterator&amp;) noexcept;

    class <a href="#Class-recursive_directory_iterator">recursive_directory_iterator</a>;

    // enable recursive_directory_iterator range-based for statements
    recursive_directory_iterator <a href="#rec.dir.itr.nonmembers">begin</a>(recursive_directory_iterator iter) noexcept;
    recursive_directory_iterator <a href="#rec.dir.itr.nonmembers">end</a>(const recursive_directory_iterator&amp;) noexcept;

    enum class file_type;  // [<a href="#Enum-file_type">enum.file_type</a>]

    enum class perms;  // [<a href="#enum.perms">enum.perms</a>]

    class <a href="#file_status">file_status</a>;

    struct <a name="space_info">space_info</a>  // returned by <a href="#space" style="text-decoration: none">space</a> function
    {
      uintmax_t capacity;
      uintmax_t free; 
      uintmax_t available;
    };

    enum class <a name="copy_option" href="#enum.copy_options">copy_options</a>;  // [<a href="#enum.copy_options">enum.copy_options</a>]

    enum class <a name="symlink_option">directory_options</a>
    {
      none,
      follow_directory_symlink,
      skip_permission_denied
    };

    typedef chrono::time_point&lt;<b><i>trivial-clock</i></b>&gt;  file_time_type;

    // <a href="#Operational-functions">operational functions</a>

    path         <a href="#absolute">absolute</a>(const path&amp; p, const path&amp; base=current_path());

    path         <a href="#canonical">canonical</a>(const path&amp; p, const path&amp; base = current_path());
    path         <a href="#canonical">canonical</a>(const path&amp; p, error_code&amp; ec);
    path         <a href="#canonical">canonical</a>(const path&amp; p, const path&amp; base, error_code&amp; ec);

    void         <a href="#copy">copy</a>(const path&amp; from, const path&amp; to);
    void         <a href="#copy">copy</a>(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;
    void         copy(const path&amp; from, const path&amp; to, copy_options options);
    void         copy(const path&amp; from, const path&amp; to, copy_options options,  
                   error_code&amp; ec) noexcept;

    bool         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to);
    bool         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;
    bool         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> option);
    bool         <a href="#copy_file">copy_file</a>(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> option,
                           error_code&amp; ec) noexcept;

    void         <a href="#copy_symlink">copy_symlink</a>(const path&amp; existing_symlink, const path&amp; new_symlink);
    void         <a href="#copy_symlink">copy_symlink</a>(const path&amp; existing_symlink, const path&amp; new_symlink,
                              error_code&amp; ec) noexcept;

    bool         <a href="#create_directories">create_directories</a>(const path&amp; p);
    bool         <a href="#create_directories">create_directories</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#create_directory">create_directory</a>(const path&amp; p);
    bool         <a href="#create_directory">create_directory</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#create_directory2">create_directory</a>(const path&amp; p, const path&amp; attributes);
    bool         <a href="#create_directory2">create_directory</a>(const path&amp; p, const path&amp; attributes,
                                  error_code&amp; ec) noexcept;

    void         <a href="#create_directory_symlink">create_directory_symlink</a>(const path&amp; to, const path&amp; new_symlink);
    void         <a href="#create_directory_symlink">create_directory_symlink</a>(const path&amp; to, const path&amp; new_symlink,
                                          error_code&amp; ec) noexcept;

    void         <a href="#create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link);
    void         <a href="#create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link,
                                  error_code&amp; ec) noexcept;

    void         <a href="#create_symlink">create_symlink</a>(const path&amp; to, const path&amp; new_symlink);
    void         <a href="#create_symlink">create_symlink</a>(const path&amp; to, const path&amp; new_symlink,
                                error_code&amp; ec) noexcept;

    path         <a href="#current_path">current_path</a>();
    path         <a href="#current_path">current_path</a>(error_code&amp; ec);
    void         <a href="#current_path">current_path</a>(const path&amp; p);
    void         <a href="#current_path">current_path</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#exists">exists</a>(file_status s) noexcept;
    bool         <a href="#exists">exists</a>(const path&amp; p);
    bool         <a href="#exists">exists</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2);
    bool         <a href="#equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2, error_code&amp; ec) noexcept;

    uintmax_t    <a href="#file_size">file_size</a>(const path&amp; p);
    uintmax_t    <a href="#file_size">file_size</a>(const path&amp; p, error_code&amp; ec) noexcept;

    uintmax_t    <a href="#hard_link_count">hard_link_count</a>(const path&amp; p);
    uintmax_t    <a href="#hard_link_count">hard_link_count</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_block_file">is_block_file</a>(file_status s) noexcept;
    bool         <a href="#is_block_file">is_block_file</a>(const path&amp; p);
    bool         <a href="#is_block_file">is_block_file</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_character_file">is_character_file</a>(file_status s) noexcept;
    bool         <a href="#is_character_file">is_character_file</a>(const path&amp; p);
    bool         <a href="#is_character_file">is_character_file</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_directory">is_directory</a>(file_status s) noexcept;
    bool         <a href="#is_directory">is_directory</a>(const path&amp; p);
    bool         <a href="#is_directory">is_directory</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_empty">is_empty</a>(const path&amp; p);
    bool         <a href="#is_empty">is_empty</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_fifo">is_fifo</a>(file_status s) noexcept;
    bool         <a href="#is_fifo">is_fifo</a>(const path&amp; p);
    bool         <a href="#is_fifo">is_fifo</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_other">is_other</a>(file_status s) noexcept;
    bool         <a href="#is_other2">is_other</a>(const path&amp; p);
    bool         <a href="#is_other2">is_other</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_regular_file">is_regular_file</a>(file_status s) noexcept; 
    bool         i<a href="#is_regular_file2">s_regular_file</a>(const path&amp; p);
    bool         i<a href="#is_regular_file2">s_regular_file</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_socket">is_socket</a>(file_status s) noexcept;
    bool         <a href="#is_socket">is_socket</a>(const path&amp; p);
    bool         <a href="#is_socket">is_socket</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#is_symlink">is_symlink</a>(file_status s) noexcept;
    bool         <a href="#is_symlink2">is_symlink</a>(const path&amp; p);
    bool         <a href="#is_symlink2">is_symlink</a>(const path&amp; p, error_code&amp; ec) noexcept;

    file_time_type  <a href="#last_write_time">last_write_time</a>(const path&amp; p);
    file_time_type  <a href="#last_write_time">last_write_time</a>(const path&amp; p, error_code&amp; ec) noexcept;
    void         <a href="#last_write_time2">last_write_time</a>(const path&amp; p, file_time_type new_time);
    void         <a href="#last_write_time2">last_write_time</a>(const path&amp; p, file_time_type new_time,
                                 error_code&amp; ec) noexcept;
                                 
    void         <a href="#fs.op.permissions">permissions</a>(const path&amp; p, perms prms);
    void         <a href="#fs.op.permissions">permissions</a>(const path&amp; p, perms prms, error_code&amp; ec) noexcept;

    path         <a href="#read_symlink">read_symlink</a>(const path&amp; p);
    path         <a href="#read_symlink">read_symlink</a>(const path&amp; p, error_code&amp; ec);

    bool         <a href="#remove">remove</a>(const path&amp; p);
    bool         <a href="#remove">remove</a>(const path&amp; p, error_code&amp; ec) noexcept;

    uintmax_t    <a href="#remove_all">remove_all</a>(const path&amp; p);
    uintmax_t    <a href="#remove_all">remove_all</a>(const path&amp; p, error_code&amp; ec) noexcept;

    void         <a href="#rename">rename</a>(const path&amp; from, const path&amp; to);
    void         <a href="#rename">rename</a>(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;

    void         <a href="#resize_file">resize_file</a>(const path&amp; p, uintmax_t size);
    void         <a href="#resize_file2">resize_file</a>(const path&amp; p, uintmax_t size, error_code&amp; ec) noexcept;

    <a href="#space_info">space_info</a>   <a href="#space">space</a>(const path&amp; p);
    <a href="#space_info">space_info</a>   <a href="#space">space</a>(const path&amp; p, error_code&amp; ec) noexcept;

    <a href="#file_status">file_status</a>  <a href="#status">status</a>(const path&amp; p);
    <a href="#file_status">file_status</a>  <a href="#status">status</a>(const path&amp; p, error_code&amp; ec) noexcept;

    bool         <a href="#status_known">status_known</a>(file_status s) noexcept;

    <a href="#file_status">file_status</a>  <a href="#symlink_status">symlink_status</a>(const path&amp; p);
    <a href="#file_status">file_status</a>  <a href="#symlink_status">symlink_status</a>(const path&amp; p, error_code&amp; ec) noexcept;

    path         <a href="#system_complete">system_complete</a>(const path&amp; p);
    path         <a href="#system_complete">system_complete</a>(const path&amp; p, error_code&amp; ec);

    path         <a href="#temp_directory_path">temp_directory_path</a>();
    path         <a href="#temp_directory_path">temp_directory_path</a>(error_code&amp; ec);

} } } }  // namespaces std::experimental::filesystem::v1</pre>

 <p><b><i><code>trivial-clock</code></i></b> is an implementation-defined type that satisfies the
<code>TrivialClock</code> requirements (C++11 §20.12.3) 
 and that is capable of representing and measuring file time values. 
 Implementations should ensure that the resolution and range of <tt>
 file_time_type</tt> reflect the operating system dependent resolution and range 
 of file time values.</p>
<h2>7  <a name="Error-reporting">Error reporting</a> [fs.err.report]</h2>
<p>Filesystem library functions often provide two overloads, one that 
throws an exception to report file system errors, and another that sets an <code>error_code</code>.</p>
<blockquote>
<p>[<i>Note:</i> This supports two common use cases:</p>
<ul>
  <li>Uses where file system 
errors are truly exceptional and indicate a serious failure. Throwing an 
  exception is the most appropriate response. This is the preferred default for 
  most everyday programming.<br>
&nbsp;</li>
  <li>Uses where file system <del>system</del> errors are routine and do not necessarily represent 
  failure. Returning an error code is the most appropriate response. This allows 
  application specific error handling, including simply ignoring the error.</li>
</ul>
  <p><i>&mdash;end note</i>]</p>
</blockquote>
<p>Functions <b>not</b> having an argument of type <code>error_code&amp;</code> report errors as follows, unless otherwise specified:</p>
  <ul>
  <li>When a call by the 
  implementation to an operating system or other underlying API results in an 
  error that prevents the function from meeting its specifications, an exception 
  of type
<code>filesystem_error</code> shall be thrown. For functions with a single path 
  argument, that argument shall be passed to the
<code>filesystem_error</code> constructor with a single path argument.&nbsp; For 
  functions with two path arguments, the first of these arguments shall be 
  passed to the
<code>filesystem_error</code> constructor as the <code>path1</code> argument, 
  and the second shall be passed as the <code>path2</code> argument. The
  <code>filesystem_error</code> constructor&#39;s <code>error_code</code> argument 
  is set as appropriate for the specific operating system dependent error. <br>
&nbsp;</li>
  <li>Failure to allocate storage is reported by throwing an exception as described in C++11 
  §17.6.4.10.<br>
&nbsp;</li>
  <li>Destructors throw nothing.</li>
  </ul>
  <p>Functions having an argument of type <code>error_code&amp;</code> report errors as follows, unless otherwise 
  specified:</p>
<ul>
  <li>If a call by the 
  implementation to an operating system or other underlying API results in an 
  error that prevents the function from meeting its specifications, the
<code>error_code&amp;</code> argument is set as 
  appropriate for the specific operating system dependent error. Otherwise, <code>clear()</code> 
  is called on the
<code>error_code&amp;</code> argument.</li>
</ul>
<h2>8  <a name="class-path">Class <code>path</code> [class.path]</a></h2>
<p>An object of class <code>path</code> represents a <a href="#class-path">path</a>, 
and contains a <a href="#fs.def.pathname">pathname</a> Such an object is concerned only with the lexical and syntactic aspects 
of a path. The path does not necessarily exist in external storage, and the 
pathname is not necessarily valid for the current operating 
system or for a particular file system.</p>
<blockquote>
<pre>namespace std { namespace experimental { namespace filesystem { inline namespace v1 {

      class path
      {
      public:
        typedef <b><i><a href="#value_type">see below</a></i></b>                      value_type;
        typedef basic_string&lt;value_type&gt;       string_type;
        static constexpr value_type            preferred_separator = <b><i><a href="#value_type">see below</a></i></b>;

        // <a href="#path-constructors">constructors</a> and destructor
        path();
        path(const path& p);
        path(path&amp;&amp; p) noexcept;
        template &lt;class <a href="#Source">Source</a>&gt;
          path(Source const&amp; source);
        template &lt;class InputIterator&gt;
          path(InputIterator first, InputIterator last);
        template &lt;class <a href="#Source">Source</a>&gt;  
          path(Source const&amp; source, const locale&amp; loc);
        template &lt;class InputIterator&gt;
          path(InputIterator first, InputIterator last, const locale&amp; loc);
       ~path(;

        // <a href="#path-assignments">assignments</a>
        path&amp; operator=(const path&amp; p);
        path&amp; operator=(path&amp;&amp; p) noexcept;
        template &lt;class <a href="#Source">Source</a>&gt;
          path&amp; operator=(Source const&amp; source);
        template &lt;class <a href="#Source">Source</a>&gt;
          path&amp; assign(Source const&amp; source)
        template &lt;class InputIterator&gt;
          path&amp; assign(InputIterator first, InputIterator last);

        // <a href="#path-appends">appends</a>
        path&amp; operator/=(const path&amp; p);
        template &lt;class <a href="#Source">Source</a>&gt;
          path&amp; operator/=(Source const&amp; source);
        template &lt;class <a href="#Source">Source</a>&gt;
          path&amp; append(Source const&amp; source);
        template &lt;class InputIterator&gt;
          path&amp; append(InputIterator first, InputIterator last);

        // <a href="#path-concatenation">concatenation</a>
        path&amp; operator+=(const path&amp; x);
        path&amp; operator+=(const string_type&amp; x);
        path&amp; operator+=(const value_type* x);
        path&amp; operator+=(value_type x);
        template &lt;class Source&gt;
          path&amp; operator+=(Source const&amp; x);
        template &lt;class charT&gt;
          path&amp; operator+=(charT x);
        template &lt;class Source&gt;
          path&amp; concat(Source const&amp; x);
        template &lt;class InputIterator&gt;
          path&amp; concat(InputIterator first, InputIterator last);
        
        // <a href="#path-modifiers">modifiers</a>
        void  <a href="#path-clear">clear</a>() noexcept;
        path&amp; <a href="#path-make_preferred">make_preferred</a>();
        path&amp; <a href="#path-remove_filename">remove_filename</a>();
        path&amp; <a href="#replace_filename">replace_filename</a>(const path&amp; replacement);
        path&amp; <a href="#path-replace_extension">replace_extension</a>(const path&amp; replacement = path());
        void  <a href="#path-swap">swap</a>(path&amp; rhs) noexcept;

        // <a href="#path-native-format-observers">native format observers</a>
        const string_type&amp;  <a href="#native">native</a>() const noexcept;
        const value_type*   <a href="#c_str">c_str</a>() const noexcept;
        <a href="#operator-string_type">operator string_type</a>() const;

        template &lt;class charT, class traits = char_traits&lt;charT&gt;,
                  class Allocator = allocator&lt;charT&gt; &gt;
        basic_string&lt;charT, traits, Allocator&gt;
          <a href="#string-template">string</a>(const Allocator&amp; a = Allocator()) const;
        string    <a href="#string">string</a>() const;
        wstring   <a href="#wstring">wstring</a>() const;
        string    u8string() const;
        u16string <a href="#u16string">u16string</a>() const;
        u32string <a href="#u32string">u32string</a>() const;

        // <a href="#path-generic-format-observers">generic format observers</a>
        template &lt;class charT, class traits = char_traits&lt;charT&gt;,
                  class Allocator = allocator&lt;charT&gt; &gt;
        basic_string&lt;charT, traits, Allocator&gt;
          <a href="#generic_string-template">generic_string</a>(const Allocator&amp; a = Allocator()) const;
        string    <a href="#generic_string">generic_string</a>() const;
        wstring   <a href="#generic_wstring">generic_wstring</a>() const;
        string    generic_u8string() const;
        u16string <a href="#generic_u16string">generic_u16string</a>() const;
        u32string <a href="#generic_u32string">generic_u32string</a>() const;

        // <a href="#path-compare">compare</a>
        int  <a href="#path-compare">compare</a>(const path&amp; p) const noexcept;
        int  <a href="#path-compare">compare</a>(const string_type&amp; s) const;
        int  <a href="#path-compare">compare</a>(const value_type* s) const;

        // <a href="#path-decomposition">decomposition</a>
        path <a href="#path-root_name">root_name</a>() const;
        path <a href="#path-root_directory">root_directory</a>() const;
        path <a href="#path-root_path">root_path</a>() const;
        path <a href="#path-relative_path">relative_path</a>() const;
        path <a href="#path-parent_path">parent_path</a>() const;
        path <a href="#path-filename">filename</a>() const;
        path <a href="#path-stem">stem</a>() const;
        path <a href="#path-extension">extension</a>() const;

        // <a href="#path-query">query</a>
        bool <a href="#path-query">empty</a>() const noexcept;
        bool <a href="#path-has_root_name">has_root_name</a>() const;
        bool <a href="#path-has_root_directory">has_root_directory</a>() const;
        bool <a href="#path-has_root_path">has_root_path</a>() const;
        bool <a href="#path-has_relative_path">has_relative_path</a>() const;
        bool <a href="#path-has_parent_path">has_parent_path</a>() const;
        bool <a href="#path-has_filename">has_filename</a>() const;
        bool <a href="#path-has_stem">has_stem</a>() const;
        bool <a href="#path-has_extension">has_extension</a>() const;
        bool <a href="#path-is_absolute">is_absolute</a>() const;
        bool <a href="#path-is_relative">is_relative</a>() const;

        // <a href="#path-iterators">iterators</a>
        class iterator;
        typedef iterator const_iterator;

        iterator begin() const;
        iterator end() const;

      private:
        string_type pathname;  // <b><i>exposition only</i></b>
      };

} } } }  // namespaces std::experimental::filesystem::v1</pre>

</blockquote>
<p><code><a name="value_type">value_type</a></code> is a <code>typedef</code> for the 
operating system dependent encoded character type used  to represent pathnames.</p>
<p>The value of <a name="preferred_separator"><code>preferred_separator</code></a> 
is the operating system dependent <i>preferred-separator</i> character ([path.generic]).</p>
<blockquote>
  [<i>Example:</i> For  POSIX based operating 
      systems, <code>value_type</code> is <code>char</code> and <code>
      preferred_separator</code> is the slash character (/).&nbsp; For Windows based 
operating systems, <code>value_type</code> is <code>wchar_t</code> and <code>
      preferred_separator</code> is the backslash character (\).&nbsp; <i>&mdash;end example</i>]
</blockquote>
<h3>8.1  <code>path</code> generic pathname format grammar [<a name="path.generic">path.generic</a>]</h3>
<p><i>pathname:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root-name 
root-directory<sub>opt</sub> relative-path<sub>opt<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>root-directory relative-path<sub>opt<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </sub>relative-path</i></p>
<p><i>root-name:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>An 
operating system dependent name that identifies the starting location for 
absolute paths. </p>
<blockquote>
  <blockquote>
<p>[<i>Note:</i> Many operating systems define a name 
beginning with two <i>directory-separator</i> characters as a <i>root-name</i> 
that identifies network or other resource locations. Some operating systems define a single letter followed by a colon as a drive 
specifier - a <i>root-name</i> identifying a specific device such as a disc drive. <i>&mdash;end note</i>]</p>
  </blockquote>
</blockquote>
<p><i>root-directory:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
directory-separator<br>
<br>
relative-path:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
filename<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relative-path 
directory-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; relative-path 
directory-separator filename<br>
<br>
filename:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dot<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dot-dot<br>
<br>
name:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>A 
sequence of characters other than <i>directory-separator</i> characters.</p>
<blockquote>
<blockquote>
[<i>Note:</i> Operating systems often place restrictions 
      on the characters that may be used in a <i>filename</i>. For wide 
      portability, users may wish to limit <i>filename</i> characters to the  POSIX Portable Filename Character Set: <br>
      <br>
      <tt>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z<br>
      a b c d e f g h i j k l m n o p q r s t u v w x y z<br>
      0 1 2 3 4 5 6 7 8 9 . _ -</tt>
      <p><i>&mdash;end note</i>]</p>
</blockquote>
</blockquote>
<p><i>dot:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>The 
filename consisting solely of a single period character (.).<br>
<br>
<i>dot-dot:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>The 
filename consisting solely of two period characters (..).<br>
<br>
<i>directory-separator:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slash<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slash directory-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; preferred-separator<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; preferred-separator directory-separator<br>
<br>
preferred-separator:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>An 
operating system dependent directory separator character. May be a synonym for
<i>slash</i>.<br>
<br>
<i>slash:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </i>The slash 
character (/). </p>
<p>Multiple successive <i>directory-separator</i> characters are considered to 
be the same as one <i>directory-separator</i> character.</p>
<p>The filename <i>dot</i> is treated as a reference to the current directory. The filename <i>
dot-dot</i> is treated as a reference to the 
parent 
directory.<ins> What the filename <i>dot-dot</i> refers to relative to <i>
root-directory</i> is implementation-defined.</ins> Specific filenames may have special meanings for a particular 
operating system.</p>
<h3>8.2  <a name="path-Conversions"><code>path</code> conversions</a> [path.cvt]</h3>
<h4>8.2.1  <a name="path-Conversions-to-native-format"><code>path</code> argument format 
conversions</a> [path.fmt.cvt]</h4>

<blockquote>
[<i>Note:</i> The format conversions described in this 
      section are not applied on POSIX or Windows based operating systems 
      because on these systems:<ul>
        <li>The generic format is acceptable as a native path.</li>
        <li>There is no need to distinguish between native format and generic 
        format arguments.</li>
        <li>Paths for regular files and paths for directories share the same 
        syntax.</li>
      </ul>
      <p>&nbsp;<i>&mdash;end note</i>]
</blockquote>

<p>Functions arguments that take character sequences representing paths 
may use the generic pathname format grammar ([<a href="#path.generic">path.generic</a>]) or 
the <a href="#fs.def.native">native pathname format</a>. If and only if such 
arguments are in the generic format and the generic format is not acceptable to 
the operating system as a native path, conversion to native format shall be 
performed during the processing of the argument. </p>
<blockquote>
<p>[<i>Note:</i> Some operating systems may have no unambiguous way to distinguish between native format and generic format arguments. 
This is by design as it simplifies use for operating systems that do not require 
disambiguation. An implementation for an operating system where disambiguation 
is required is permitted 
as an extension to distinguish between the formats. <i>
&mdash;end note</i>]</p>
</blockquote>

<p>If the native format requires paths for regular files to be formatted 
differently from paths for directories, the path shall be treated as a directory 
path if last element is <i>directory-separator</i>, 
otherwise it shall be treated as a regular file path.</p>

<h4>8.2.2  <code>path</code> type and encoding conversions [<a name="path.arg.convert">path.type.cvt</a>]</h4>
<p>For member function arguments that take character sequences representing 
paths and for member functions returning strings, value type and encoding 
conversion is performed if the value type of the argument or return differs from <code>
path::value_type</code>. Encoding 
and method of conversion for the argument or return value
to be converted to is determined 
by its value type:</p>
<blockquote>
  <ul>
    <li>
<p><code>char</code>: Encoding is the native narrow encoding ([fs.def.native.encode]). Conversion, if any, is operating system dependent.<p>[<i>Note:</i> 
For POSIX based operating systems <code>path::value_type</code> is <code>char</code> 
so no conversion from <code>char</code> value type arguments or to <code>char</code> 
value type returns is performed.<p>For Windows based operating systems, the 
native narrow  encoding is determined by calling a  Windows API function. <i>&mdash;end note</i>]<p><i><span style="background-color: #E0E0E0">On Windows, the encoding is determined by testing <code>AreFileApisANSI()</code>; if true, the <code>CP_ACP</code> 
        codepage applies, otherwise the <code>CP_OEMCP</code> codepage applies. </span></i><p>[<i>Note:</i> 
This results in behavior identical to other C and C++ 
standard library functions that perform file operations using narrow character 
strings to identify paths. Changing this  behavior would be surprising and error 
prone. <i>&mdash;end note</i>]<br>
&nbsp;<p>
</p>
    </li>
    <li>
<p><code>wchar_t</code>: Encoding is the native wide encoding ([fs.def.native.encode]). Conversion method is unspecified.</p>
    <p>[<i>Note:</i> 
For Windows based operating systems <code>path::value_type</code> is <code>wchar_t</code> 
so no conversion from <code>wchar_t</code> value type arguments or to <code>wchar_t</code> 
    value type returns is performed. <i>&mdash;end note</i>]<br>
&nbsp;</li>
    <li>
<p><code>char16_t</code>: Encoding is UTF-16. Conversion method 
is unspecified. <br>
&nbsp;</p>
    </li>
    <li>
<p><code>char32_t</code>: Encoding is UTF-32. Conversion method 
is unspecified.</p>
    </li>
  </ul>
</blockquote>
<p>If the encoding being converted to has no representation for source 
characters, the resulting converted characters, if any, are unspecified.</p>

<h3>8.3  <a name="path-Requirements"><code>path</code> requirements</a> [path.req]</h3>
<p>In addition to the [fs.req] requirements, function template parameters named <code><a name="Source">Source</a></code> 
shall be one of:</p>
<ul>
  <li>
  <p> <code>basic_string&lt;charT, traits, Allocator&gt;</code>. The type <code>
  charT</code> shall be an encoded character type ([fs.req]).&nbsp; A function 
  argument <code>Source const&amp;</code> <code>source</code> shall have an 
  effective range [<code>source.begin()</code>, <code>source.end()</code>).</li>
  <li>
  <p>A type meeting the input iterator requirements that iterates over a NTCTS. 
  The value type shall be an encoded character type. A function argument <code>
  Source const&amp;</code> <code>source</code> shall have an effective range&nbsp; 
  [<code>source</code>, <code>end</code>) where <code>end</code> is the first 
  iterator value with an element value equal to <code>iterator_traits&lt;Source&gt;::<wbr />value_type()</code>.</li>
  <li>A character array that after array-to-pointer decay results in a 
  pointer to a NTCTS. The value type shall be an encoded character type. A 
  function argument <code>Source const&amp;</code> <code>source</code> shall 
  have an effective range [<code>source</code>, <code>end</code>) where <code>
  end</code> is the first iterator value with an element value equal to <code>iterator_traits&lt;decay&lt;Source&gt;:<wbr />:type&gt;::value_type()</code>.</li>
</ul>

<blockquote>
  <p>[<i>Note:</i> See <a href="#path-Conversions">path conversions</a> ([path.cvt]) 
  for how these value types and their encodings convert to <code>
  path::value_type</code> and its encoding. <i>&mdash;end note</i>]</p>
</blockquote>

  <p>Arguments of type <code>Source</code> 
  shall not be null pointers.</p>

  <h3>8.4  <code>path</code> members&nbsp; [<a name="path.member">path.member</a>]</h3>

<h4>8.4.1  <a name="path-constructors"> <code>path</code> constructors</a> [path.construct]</h4>
<pre>path();</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of class <code>path</code>.</p>
  <p><i>Postconditions:</i> <code>empty()</code>.</p>
</blockquote>
<pre>path(const path&amp; p);
path(path&amp;&amp; p) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of class <code>path</code> with <code>
  pathname</code> having the original value of <code>p.pathname</code>. In the 
  second form, <code>p</code> is left in a valid but unspecified state.</p>
</blockquote>
<pre>template &lt;class <a href="#Source">Source</a>&gt;
  path(Source const&amp; source);
template &lt;class InputIterator&gt;
  path(InputIterator first, InputIterator last);</pre>
<blockquote>
  <p><i>Effects:</i> Constructs an object of class <code>path</code>, storing the effective range of <code>source</code> ([<a href="#path-Requirements">path.req</a>]) 
  or the range [<code>first</code>,<code>last</code>) in <code>pathname</code>, converting format and 
  encoding if required ([<a href="#path.arg.convert">path.arg.convert</a>]).</p>
</blockquote>
<pre>template &lt;class <a href="#Source">Source</a>&gt;
  path(Source const&amp; source, const locale&amp; loc);
template &lt;class InputIterator&gt;
  path(InputIterator first, InputIterator last, const locale&amp; loc);</pre>
  <blockquote>
  <p><i>Requires:</i> The value type of <code>Source</code> and <code>InputIterator</code> is <code>
  char</code>.</p>
  <p><i>Effects:</i> Constructs an object of class <code>path</code>, storing the effective range of <code>
  source</code> 
  or the range [<code>first</code>,<code>last</code>) in <code>pathname</code>, 
  after converting format if required and after converting the encoding as 
  follows:</p>
  <blockquote>
  <p>If <code>value_type</code> is <code>wchar_t</code>, converts to the 
  native wide encoding ([fs.def.native.encode]) using the <code>codecvt&lt;wchar_t, char&gt;</code> 
  facet of <code>loc</code>. Otherwise a conversion is performed using the <code>
  codecvt&lt;wchar_t, char&gt;</code> facet of <code>loc</code>, and then a second 
  conversion to the current narrow encoding. </p>
  </blockquote>
  <p>[<i>Example</i>:</p>
    <blockquote>
  <p>A string is to be read from a database 
  that is encoded in ISO/IEC 8859-1, and used to create a directory:</p>
      <pre>namespace fs = std::experimental::filesystem;
std::string latin1_string = read_latin1_data();
codecvt_8859_1&lt;wchar_t&gt; latin1_facet;
std::locale latin1_locale(std::locale(), latin1_facet);
fs::create_directory(fs::path(latin1_string, latin1_locale));</pre>
    <p>For POSIX based operating systems the path is constructed by first using <code>
    latin1_facet</code> to convert ISO/IEC 8859-1 encoded
    <code>latin1_string</code> to a wide character string in the native wide 
    encoding ([fs.def.native.encode]). The resulting wide string is then 
    converted to a narrow character
    <code>pathname</code> string in the current native narrow encoding. If the 
    native wide encoding is UTF-16 or UTF-32, and the current native narrow 
    encoding is UTF-8, all of the characters in the ISO/IEC 8859-1 character set 
    will be converted to their Unicode representation, but for other native 
    narrow encodings some characters may have no representation. </p>                                                   
    <p>For Windows based operating systems the path is constructed by 
    using <code>latin1_facet</code> to convert ISO/IEC 8859-1 encoded <code>
    latin1_string</code> to a UTF-16 encoded wide character <code>pathname</code> 
    string. All of the characters in the ISO/IEC 8859-1 character set will be 
    converted to their Unicode representation.</p>                                                   
    </blockquote>
<p> <i>&mdash;end example]</i> </p>
</blockquote>
<h4>8.4.2  <a name="path-assignments"><code>path</code> assignments</a> [path.assign]</h4>
<pre>path&amp; operator=(const path&amp; p);</pre>
<blockquote>
  <p><i>Effects: </i>If <code>*this</code> and <code>p</code> are the same 
  object, has no effect. Otherwise, modifies <code>pathname</code> to have the 
  original value of <code>p.pathname</code>.</p>
  <p>
  <i>Returns: </i><code>*this</code></p>
</blockquote>
<pre>path&amp; operator=(path&amp;&amp; p) noexcept;</pre>
<blockquote>
  <p><i>Effects: </i>If <code>*this</code> and <code>p</code> are the same 
  object, has no effect. Otherwise, modifies <code>pathname</code> to have the 
  original value of <code>p.pathname</code>.&nbsp; <code>p</code> is left in a 
  valid but unspecified state. [<i>Note:</i> A valid implementation is <code>
  swap(p)</code>. <i>—end note</i>]</p>
  <p>
  <i>Returns: </i><code>*this</code></p>
</blockquote>
<pre>template &lt;class <a href="#Source">Source</a>&gt;
  path&amp; operator=(Source const&amp; source);
template &lt;class <a href="#Source">Source</a>&gt;
  path&amp; assign(Source const&amp; source);
template &lt;class InputIterator&gt;
  path&amp; assign(InputIterator first, InputIterator last);</pre>
<blockquote>
  <p><i>Effects:</i> Stores the effective range of <code>source</code> ([<a href="#path-Requirements">path.req</a>]) 
  or the range [<code>first</code>,<code>last</code>) in <code>pathname</code>, converting format and 
  encoding if required ([<a href="#path.arg.convert">path.arg.convert</a>]). </p>
  <p>
  <i>Returns: </i><code>*this</code></p>
  </blockquote>
<h4>8.4.3  <a name="path-appends"><code>path</code> appends</a> 
[path.append]</h4>
  <p>The append operations use <code>
  operator/=</code> to denote their semantic effect of appending <i>
  preferred-separator</i> when needed. </p>
<pre>path&amp; operator/=(const path&amp; p);</pre>
<blockquote>
  <p><i>Effects:</i></p>
  <blockquote>
    Appends <code>path::preferred_separator</code> to <code>pathname</code> unless:<ul>
    <li>an added separator 
    would be redundant, or</li>
    <li>would change a relative path to a absolute path
    [<i>Note</i>: An empty path is relative. — <i>end note</i>], or</li>
    <li><code>p.empty()</code>, or</li>
    <li><code>*p.native().cbegin()</code> is a directory separator.</li>
  </ul>
    <p>Then appends <code>p.native()</code> to <code>pathname</code>.</p>
  </blockquote>
  <p><i>Returns: </i><code>*this</code></p>
</blockquote>
<pre>template &lt;class <a href="#Source">Source</a>&gt;
  path&amp; operator/=(Source const&amp; source);
template &lt;class <a href="#Source">Source</a>&gt;
  path&amp; append(Source const&amp; source);
template &lt;class InputIterator&gt;
  path&amp; append(InputIterator first, InputIterator last);</pre>
<blockquote>
  <p><i>Effects:</i></p>
  <blockquote>
    <p>Appends <code>path::preferred_separator</code> to <code>pathname</code>, converting 
    format and encoding if required ([<a href="#path.arg.convert">path.arg.convert</a>]), unless:</p>
    <ul>
    <li>an added separator 
    would be redundant, or</li>
    <li>would change an relative path to an absolute path, or</li>
    <li><code><del>p</del><ins>source</ins>.empty()</code>, or</li>
    <li><code>*<del>p</del><ins>source</ins>.native().cbegin()</code> is a separator.</li>
  </ul>
    <p>Appends the effective range of <code>source</code> ([<a href="#path-Requirements">path.req</a>]) 
    or the range [<code>first</code>,<code>last</code>) to <code>pathname</code>, converting format and 
    encoding if required ([<a href="#path.arg.convert">path.arg.convert</a>]).</p>
  </blockquote>
  <p><i>Returns: </i><code>*this</code></p>
  </blockquote>
  
<h4>8.4.4  <a name="path-concatenation"><code>path</code> concatenation</a> [path.concat]</h4>
<pre>path&amp; operator+=(const path&amp; x);
path&amp; operator+=(const string_type&amp; x);
path&amp; operator+=(const value_type* x);
path&amp; operator+=(value_type x);
template &lt;class Source&gt;
  path&amp; operator+=(Source const&amp; x);
template &lt;class charT&gt;
  path&amp; operator+=(charT x);
template &lt;class Source&gt;
  path&amp; concat(Source const&amp; x);
template &lt;class InputIterator&gt;
  path&amp; concat(InputIterator first, InputIterator last);</pre>
<blockquote><p><i>Postcondition:</i> <code>native() == prior_native + <i>effective-argument</i></code>,
 where <code>prior_native</code> is <code>native()</code> prior to the call to <code>operator+=</code>,
 and <code><i>effective-argument</i></code> is:</p>
 <ul><li><code>x.native()</code> if <code>x</code> is present and is <code>const path&amp;</code>, otherwise</li>
 <li>the effective range <code>source</code> ([<a href="#path-Requirements">path.req</a>]), 
 if <code>source</code> is present, otherwise,</li>
 <li>the range [<code>first</code>,<code>last</code>),
 if <code>first</code> and
 <code>last</code> are present, otherwise,</li>
 <li><code>x</code>.</li></ul><p>If the value type of <code><i>effective-argument</i></code> would not be <code>path::value_type</code>, the actual argument or argument range is first
   converted ([<a href="#path.arg.convert">path.arg.convert</a>]) so that <code><i>effective-argument</i></code> has value type <code>path::value_type</code>.</li> </p>
 <p><i>Returns: </i><code>*this</code></p>
 </blockquote>
<h4>8.4.5  <a name="path-modifiers"> <code>path</code> modifiers</a> [path.modifiers]</h4><pre>void <a name="path-clear">clear</a>() noexcept;</pre>
<blockquote>
<p><i>Postcondition:</i> <code>empty()</code></p>
</blockquote>
<pre>path&amp; <a name="path-make_preferred">make_preferred</a>();</pre>
<blockquote>
  <p><i>Effects: </i>Each <i>directory-separator</i> 
  is converted to <i>preferred-separator</i>.</p>
  <p><i>Returns:</i> <code>*this</code></p>
<p>[<i>Example:</i></p>
  <blockquote>
    <pre><code>path p(&quot;foo/bar&quot;);
std::cout &lt;&lt; p &lt;&lt; '\n';
</code>p.make_preferred();
<code>std::cout &lt;&lt; p &lt;&lt; '\n';</code></pre>
  </blockquote>
  <p>On an operating system where <i>preferred-separator</i> is the same as <i>
  directory-separator</i>, the output is:</p>
  <blockquote>
    <pre>&quot;foo/bar&quot;
&quot;foo/bar&quot;</pre>
  </blockquote>
  <p>On an operating system where <i>preferred-separator</i> is a backslash, the 
  output is:</p>
  <blockquote>
    <pre>&quot;foo/bar&quot;
&quot;foo\bar&quot;</pre>
  </blockquote>
  <p> <i>&mdash;end example</i>]</p>
</blockquote>

<pre>path&amp; <a name="path-remove_filename">remove_filename</a>();</pre>
<blockquote>
  <p><i>Postcondition:</i> <code>!has_filename()</code>.</p>
  <p><i>Returns: </i> <code>*this</code>.</p>
  <p>[<i>Example:</i></p>
  <blockquote>
    <pre><code>std::cout &lt;&lt; path(&quot;/foo&quot;).remove_filename();</code>  // outputs &quot;<code>/</code>&quot;
std::cout &lt;&lt; path(&quot;/&quot;).<code>remove_</code>filename();     // outputs &quot;&quot;</pre>
  </blockquote>
  <p> <i>&mdash;end example</i>]</p>
</blockquote>

<pre>path&amp; <a name="replace_filename">replace_filename</a>(const path&amp; replacement);</pre>
<blockquote>
  <p><i>Effects:</i></p>
  <blockquote>
    <p><code>remove_filename();<br>
    operator/=(replacement);</code></p>
  </blockquote>
  <p><i>Returns: </i> <code>*this</code>.</p>
  <p>[<i>Example:</i></p>
  <blockquote>
    <pre><code>std::cout &lt;&lt; path(&quot;/foo&quot;).replace_filename(&quot;bar&quot;);</code>  // outputs &quot;<code>/bar</code>&quot;
std::cout &lt;&lt; path(&quot;/&quot;).<code>replace_</code>filename(<code>&quot;bar&quot;</code>);     // outputs &quot;bar&quot;</pre>
  </blockquote>
  <p> <i>&mdash;end example</i>]</p>
</blockquote>
<pre>path&amp; <a name="path-replace_extension">replace_extension</a>(const path&amp; replacement = path());</pre>
<blockquote>
  <p><i>Effects:</i></p>
  <ul>
    <li>Any existing <code>extension()</code> is removed from the stored path, 
    then</li>
    <li>If <code>replacement</code> is not empty and does not begin with a dot 
    character, a dot character is appended to the stored path, then</li>
    <li>
  <code>replacement</code> is concatenated to the stored path.</li>
  </ul>
  <p><i>Returns:</i> <code>*this</code></p>
</blockquote>
<pre><code>void <a name="path-swap">swap</a>(path&amp; rhs)</code> noexcept<code>;</code></pre>
<blockquote>
  <p><i>Effects:</i> Swaps the contents of the two paths.</p>
  <p><i>Complexity: </i>constant time.</p>
  <p><span style="background-color: #E0E0E0"><i>See 
    [c++std-filesystem-44] from Daniel Krügler for <code>noexcept</code> rationale.</span></i></p>
</blockquote>

<h4>8.4.6  <a name="path-native-format-observers"><code>path</code> native format observers</a> 
[path.native.obs]</h4>
<p>The string returned by all native format observers is in the <a href="#fs.def.native">native pathname format</a>.</p>
<pre>const string_type&amp;  <a name="native">native</a>() const noexcept;</pre>
<blockquote>
<p><i>Returns:</i> <code>pathname</code>.</p>
</blockquote>
<pre>const value_type* <a name="c_str">c_str</a>() const noexcept;</pre>
<blockquote>
<p><i>Returns:</i> <code>pathname.c_str()</code>.</p>
</blockquote>
<pre><a name="operator-string_type">operator</a> string_type() const;</pre>
<blockquote>
  <p><i>Returns: </i><code>pathname</code>.</p>
  <p>[<i>Note:</i> Conversion to <code>string_type</code> is provided so that an 
  object of class <code>path</code> can be given as an argument to existing 
  standard library file stream constructors and open functions. This provides 
  basic interoperability without the need to modify existing standard library 
  classes or headers. <i>&mdash;end note</i>]</p>
  <p><i><span style="background-color: #E0E0E0">Implementations of the standard 
  library for systems where string_type is wstring, such as Windows, are 
  encouraged to provide an extension to existing standard library file stream 
  constructors and open functions that adds overloads that accept wstrings for 
  file names. Microsoft and Dinkumware already provide such an extension. </span>
  </i></p>
</blockquote>
<p>
<pre>template &lt;class charT, class traits = char_traits&lt;charT&gt;,
          class Allocator = allocator&lt;charT&gt; &gt;
basic_string&lt;charT, traits, Allocator&gt;
  <a name="string-template">string</a>(const Allocator& a = Allocator()) const;</pre>


<blockquote>
  <p><i>Returns:</i> <code>pathname</code>.</p>
<p><i>Remarks:</i> All memory allocation, including for the return value, shall 
be performed by <code>a</code>. Conversion, if any, is  specified by [<a href="#path-Conversions">path.cvt</a>]).</p>
</blockquote>
<pre>string <a name="string">string</a>() const;
wstring <a name="wstring">wstring</a>() const;
string <a name="u8string">u8string</a>() const;
u16string <a name="u16string">u16string</a>() const;
u32string <a name="u32string">u32string</a>() const; </pre>
<blockquote>
<p><i>Returns:</i> <code>pathname</code>.</p>
<p><i>Remarks:</i> Conversion, if any, is performed as specified by [<a href="#path-Conversions">path.cvt</a>]. 
The encoding of the string returned by <code>u8string()</code> is always UTF-8.</p>
</blockquote>

<h4>8.4.7  <a name="path-generic-format-observers"><code>path</code> generic format observers</a> 
[path.generic.obs]</h4>
<p>Generic format observer functions 
 
return strings formatted according to the generic pathname format ([<a href="#path.generic">path.generic</a>]). 
The forward slash (<code>'/'</code>) character is used as the <i>
directory-separator</i> character.</p>
<blockquote>
<p>[<i>Example:</i> On an operating system that uses backslash as 
its preferred-separator,&nbsp; <code>path(&quot;foo\\bar&quot;).generic_string()</code> 
returns <code>&quot;foo/bar&quot;</code>. <i>&mdash;end example</i>]</p>
</blockquote>

<pre>template &lt;class charT, class traits = char_traits&lt;charT&gt;,
          class Allocator = allocator&lt;charT&gt; &gt;
basic_string&lt;charT, traits, Allocator&gt;
  <a name="generic_string-template">generic_string</a>(const Allocator& a = Allocator()) const;</pre>

<blockquote>
  <p><i>Returns:</i> <code>pathname</code>, reformatted according to the generic 
  pathname format ([<a href="#path.generic">path.generic</a>]). </p>
<p><i>Remarks:</i> All memory allocation, including for the return value, shall 
be performed by <code>a</code>. Conversion, if any, is  specified by [<a href="#path-Conversions">path.cvt</a>].</p>
</blockquote>
<pre>string <a name="generic_string">generic_string</a>() const;
wstring <a name="generic_wstring">generic_wstring</a>() const;
string generic_u8string() const;
u16string <a name="generic_u16string">generic_u16string</a>() const;
u32string <a name="generic_u32string">generic_u32string</a>() const; </pre>
<blockquote>
<p><i>Returns:</i> <code>pathname</code>, reformatted according to the generic 
pathname format ([<a href="#path.generic">path.generic</a>]).</p>
<p><i>Remarks:</i>&nbsp; Conversion, if any, is  specified by [<a href="#path-Conversions">path.cvt</a>]. 
The encoding of the string returned by <code>generic_u8string()</code> is always 
UTF-8.</p>
</blockquote>

<h4>8.4.8  <a name="path-compare"><code>path</code> compare</a> [path.compare]</h4>
<pre>int compare(const path&amp; p) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> A value less than 0 if <code>native()</code> for the elements of <code>*this</code> are lexicographically less than
  <code>native()</code> for the elements of <code>p</code>, otherwise a 
  value greater than 0 if <code>native()</code> for the elements of <code>*this</code> are 
  lexicographically greater than <code>native()</code> for the elements of <code>p</code>, otherwise 0.</p>
  <p>Remark: The elements are determined as if by iteration over the half-open 
  range [<code>begin()</code>, <code>end()</code>) for <code>*this</code> and&nbsp; <code>p</code>.</p>
</blockquote>
<pre>int compare(const string_type&amp; s) const</pre>
<blockquote>
  <p><i>Returns:</i> <code>compare(path(s))</code>.</p>
</blockquote>
<pre>int compare(const value_type* s) const</pre>
<blockquote>
  <p><i>Returns:</i> <code>compare(path(s))</code>.</p>
</blockquote>
<h4>8.4.9  <a name="path-decomposition"> <code>path</code> decomposition</a> 
[path.decompose]</h4>
<pre>path <a name="path-root_name">root_name</a>() const;</pre>
<blockquote>
<p><i>Returns:</i> <i>root-name,</i> if <code>pathname</code> includes <i>root-name</i>, otherwise <code>path()</code>. </p>
</blockquote>
<pre>path <a name="path-root_directory">root_directory</a>() const;</pre>
<blockquote>
<p><i>Returns:</i> <i>root-directory</i>, if <code>pathname</code> includes <i>root-directory</i>, otherwise <code>path()</code>.</p>
<p>If <i>root-directory</i> is composed of <i>slash name</i>, <i>slash</i> is 
excluded from the returned string.</p>
</blockquote>
<pre>path <a name="path-root_path">root_path</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>root_name() / root_directory()</code></p>
</blockquote>
<pre>path <a name="path-relative_path">relative_path</a>() const;</pre>
<blockquote>
<p><i>Returns:</i> A <code>path</code> composed from <code>pathname</code>, if <code>!empty()</code>, beginning 
with the first <i>filename</i> after <i>root-path</i>. Otherwise, <code>path()</code>.</p>
</blockquote>
<pre>path <a name="path-parent_path">parent_path</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>(empty() || begin() == <del>&mdash;</del><ins>--</ins>end()) ? path() : <i>pp</i></code>, where <code><i>pp</i></code> is constructed as if by 
  starting with an empty <code>path</code> and successively applying <code>operator/=</code> for each element in the range <code>begin()</code>, <code><del>&mdash;</del><ins>--</ins>end()</code>.</p>
</blockquote>
<pre>path <a name="path-filename">filename</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>empty() ? path() : *<del>&mdash;</del><ins>--</ins>end()</code></p>
  <p>[<i>Example:</i></p>
  <blockquote>
    <pre><code>std::cout &lt;&lt; path(&quot;/foo/bar.txt&quot;).filename();</code> // outputs &quot;<code>bar.txt</code>&quot;
std::cout &lt;&lt; path(&quot;/&quot;).filename();            // outputs &quot;/&quot;
std::cout &lt;&lt; path(&quot;.&quot;).filename();            // outputs &quot;.&quot;
std::cout &lt;&lt; path(&quot;..&quot;).filename();           // outputs &quot;..&quot;</pre>
  </blockquote>
  <p> <i>&mdash;end example</i>]</p>
</blockquote>
<pre>path <a name="path-stem">stem</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> if <code>filename()</code> contains a period but does not 
  consist solely of one or two periods, returns 
  the substring of <code>filename()</code> starting at its beginning and 
  ending with the character before the last period. Otherwise, 
  returns <code>filename()</code>.</p>
  <p>[<i>Example:</i></p>
  <blockquote>
    <pre><code>std::cout &lt;&lt; path(&quot;/foo/bar.txt&quot;).stem();</code> // outputs &quot;<code>bar</code>&quot;
path p = &quot;foo.bar.baz.tar&quot;;
for (; !p.extension().empty(); p = p.stem())
  std::cout &lt;&lt; p.extension() &lt;&lt; '\n';
  // outputs: .tar
  //          .baz
  //          .bar</pre>
  </blockquote>
  <p> <i>&mdash;end example</i>]</p>
</blockquote>
<pre>path <a name="path-extension">extension</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> if <code>filename()</code> contains a period but does not 
  consist solely of one or two periods, returns 
  the substring of <code>filename()</code> starting at the rightmost period 
  and for the remainder of the path. Otherwise, returns an empty <code>path</code> object. </p>
  <p><i>Remarks:</i> Implementations are permitted to define additional 
  behavior for file systems which append additional elements to extensions, such 
  as alternate data streams or partitioned dataset names.</p>
  <p>[<i>Example:</i></p>
  <blockquote>
    <pre><code>std::cout &lt;&lt; path(&quot;/foo/bar.txt&quot;).extension(); //</code> outputs &quot;<code>.txt</code>&quot;</pre>
  </blockquote>
  <p> <i>&mdash;end example</i>]</p>
  <p>[<i>Note:<b> </b></i>The period is included in the return value so that it is 
  possible to distinguish between no extension and an empty extension. Also note 
  that for a path <code>p</code>, <code>p.stem()+p.extension() == p</code>. <i>
  &mdash;end note</i>]</p>
</blockquote>
<h4>8.4.10  <a name="path-query"> <code>path</code> query</a> [path.query]</h4>
<pre>bool <a name="path-empty">empty</a>() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>pathname.empty()</code>.</p>
</blockquote>
<pre>bool <a name="path-has_root_path">has_root_path</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-root_path">root_path</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_root_name">has_root_name</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-root_name">root_name</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_root_directory">has_root_directory</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-root_directory">root_directory</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_relative_path">has_relative_path</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-has_relative_path">relative_path</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_parent_path">has_parent_path</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-parent_path">parent_path</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_filename">has_filename</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-filename">filename</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_stem">has_stem</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-stem">stem</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-has_extension">has_extension</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!<a href="#path-has_extension">extension</a>().empty()</code></p>
</blockquote>
<pre>bool <a name="path-is_absolute">is_absolute</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>true</code> if <code>pathname</code> 
  contains an absolute path (4.1 [fs.def.absolute-path]) , else <code>false</code>.</p>
</blockquote>
<blockquote>
[<i>Example:</i> <code>path(&quot;/&quot;).is_absolute()</code> is
      <code>true</code> for  POSIX based operating systems, and <code>false</code> for Windows based 
operating systems.&nbsp; <i>&mdash;end example</i>]
</blockquote>
<pre>bool <a name="path-is_relative">is_relative</a>() const;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!is_absolute()</code>.</p>
</blockquote>
<h3>8.5  <a name="path-iterators"> <code>path</code> iterators</a> [path.itr]</h3>
<p> Path iterators iterate over the elements of the stored pathname.</p>
<p> A <code>path::iterator</code> is a constant iterator satisfying all the 
requirements of a bidirectional iterator (C++11 §24.1.4 Bidirectional 
iterators). Its <code>value_type</code> is <code>path</code>.</p>
  <p>Calling any non-const member function of a <code>path</code> object 
  invalidates all iterators referring to elements of that object.</p>
<p> The forward traversal order is as follows:</p>
<ul>
  <li>The <i>root-name</i> element, if present.</li>
  <li>The <i>root-directory</i> element, if present, in the generic format. <i>
  [note:</i> the generic format is required to ensure lexicographical 
  comparison works correctly. <i>&mdash;end note</i>]</li>
  <li>Each successive <i>filename</i> element, if present.</li>
  <li><i>Dot</i>, if one or more trailing non-root <i>slash</i> 
  characters are present.</li>
</ul>
  <p>The backward traversal order is the reverse of forward traversal.</p>
  <pre>iterator begin() const;</pre>
<blockquote>
  <p><i>Returns:</i> An iterator for the first present element in the traversal 
  list above. If no elements are present, the end iterator.</p>
</blockquote>
<pre>iterator end() const;</pre>
<blockquote>
  <p><i>Returns:</i> The end iterator.</p>
</blockquote>
 <p><h3>8.6  <a name="path-non-member-functions"> <code>path</code> non-member functions</a> 
[path.non-member]</h3>
<pre>void swap(path&amp; lhs, path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Effects: </i><code>lhs.swap(rhs)</code>.</p>
</blockquote>
<pre>size_t <a name="hash_value">hash_value</a> (const path&amp; p) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> A hash value for the path <code>p</code>. If
  for two paths, <code>p1 == p2</code> then <code>hash_value(p1) == hash_value(p2)</code>.</p>
</blockquote>
<pre>bool operator&lt; (const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>return lhs.compare(rhs) &lt; 0</code>.</p>
</blockquote>
<pre>bool operator&lt;=(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!(rhs &lt; lhs)</code>.</p>
</blockquote>
<pre>bool operator&gt; (const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>rhs &lt; lhs</code>.</p>
</blockquote>
<pre>bool operator&gt;=(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!(lhs &lt; rhs)</code>.</p>
</blockquote>
<pre>bool operator==(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!(lhs &lt; rhs) &amp;&amp; !(rhs &lt; lhs)</code>.</p>
  <p>[<i>Note:</i> <a name="Path-equality">Path equality</a> and path 
  equivalence have different semantics.</p>
  <p>Equality is determined by the <code>path</code> non-member <code>operator==</code>, which considers the two path's lexical 
  representations only. Thus <code>path(&quot;foo&quot;) == &quot;bar&quot;</code> is never <code>true</code>.</p>
  <p>Equivalence is determined by the <a href="#equivalent"><code>equivalent()</code></a> non-member function, which determines if two paths <a href="#class-path">resolve</a> to the same file system entity. 
  Thus <code>equivalent(&quot;foo&quot;, &quot;bar&quot;)</code> will be <code>true</code> when both paths resolve to the same file.</p>
  <p>Programmers wishing to determine if two paths are &quot;the same&quot; must decide if 
  &quot;the same&quot; means &quot;the same representation&quot; or &quot;resolve to the same actual 
  file&quot;, and choose the appropriate function accordingly. <i>&mdash;end note</i>]</p>
</blockquote>
<pre>bool operator!=(const path&amp; lhs, const path&amp; rhs) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>!(lhs == rhs)</code>.</p>
</blockquote>
<pre>path operator/ (const path&amp; lhs, const path&amp; rhs);</pre>
<blockquote>
  <p><i>Returns:</i> <code>path(lhs) /= rhs</code>.</p>
</blockquote>
<h4>8.6.1  <a name="path-inserter-extractor"><code>path</code> inserter and extractor</a> [path.io]</h4>
<pre>template &lt;class charT, class traits&gt;
basic_ostream&lt;charT, traits&gt;&amp;
operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const path&amp; p);</pre>
<blockquote>
  <p><i>Effects:</i> <code>os </code>
  <tt>&lt;&lt; quoted(p.string&lt;charT, traits&gt;())</tt>. </p>
  <p>[<i>Note</i>: The <code>quoted</code> function is described in ISO 
  14882:2014 §27.7.6. — <i>end note</i>] </p>
  <p><i>Returns:</i> <code>os</code></p>
  </blockquote>
<pre>template &lt;class charT, class traits&gt;
basic_istream&lt;charT, traits&gt;&amp;
operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is, path&amp; p);</pre>
<blockquote>
  <p><i>Effects:&nbsp; </i></p>
  <blockquote>
    <pre>basic_string&lt;charT, traits&gt; tmp;
is &gt;&gt; quoted(tmp);
p = tmp;</pre>
  </blockquote>
  <p><i>Returns:</i> <code>is</code></p>
  </blockquote>
<h4>8.6.2  <a name="path.factory"><code>path</code> factory functions [path.factory]</a></h4>
<pre>template &lt;class <a href="#Source">Source</a>&gt;  
  path u8path(Source const&amp; source);
template &lt;class InputIterator&gt;
  path u8path(InputIterator first, InputIterator last);</pre>
<blockquote>
  <p><i>Requires:</i> The <code>source</code> and [<code>first</code>,<code>last</code>) 
  sequences are UTF-8 encoded. The value type of <code>
  Source</code> and <code>
  InputIterator</code> is <code>char</code>. </p>
  <p><i>Returns:</i></p>
  <blockquote>
    <ul>
      <li>If <code>value_type</code> is <code>char</code> and the current native 
      narrow encoding ([fs.def.native.encode]) is UTF-8, <code>path(source)</code> or <code>path(first, last)</code>, 
      else</li>
      <li>if <code>value_type</code> is <code>wchar_t </code>and the 
      native wide encoding is UTF-16, or if <code>value_type</code> is <code>char16_t</code> 
      or <code>char32_t</code>,&nbsp; convert <code>source</code> or [<code>first</code>,<code>last</code>) 
      to a temporary, <code>tmp</code>, of type <code>string_type</code> and 
      return <code>path(tmp)</code>, 
      else</li>
      <li>convert <code>source</code> or [<code>first</code>,<code>last</code>) 
      to a temporary, <code>tmp</code>, of type <code>u32string</code> and 
      return <code>path(tmp)</code>.</li>
    </ul>
  </blockquote>
  <p><i>Remarks: </i>Argument format conversion ([path.fmt.cvt]) applies to the 
  arguments for these functions. How Unicode encoding conversions are performed is 
  unspecified. </p>
  <p>[<i>Example</i>:</p>
  <blockquote>
    <p>A string is to be read from a database that is encoded in UTF-8, and used 
    to create a directory using the native encoding for filenames:</p>
    <pre>namespace fs = std::experimental::filesystem;
std::string utf8_string = read_utf8_data();
fs::create_directory(fs::u8path(utf8_string));</pre>
    <p>For POSIX based operating systems with the native narrow encoding set 
    to UTF-8, no encoding or type conversion occurs.</p>
    <p>For POSIX based operating systems with the native narrow encoding not 
    set to UTF-8, a conversion to UTF-32 occurs, followed by a conversion to the 
    current native narrow encoding. Some Unicode characters may have no native character 
    set representation.</p>
    <p>For Windows based operating systems a conversion from UTF-8 to 
    UTF-16 occurs.</p>
  </blockquote>
  <p><i>&mdash;end example]</i></p>
</blockquote>
<h2>9  <a name="Class-filesystem_error">Class <code>filesystem_error</code> 
[class.filesystem_error]</a></h2>
<pre>namespace std { namespace experimental { namespace filesystem { inline namespace v1 {

      class filesystem_error : public system_error
      {
      public:
        <a href="#filesystem_error-2-arg">filesystem_error</a>(const string&amp; what_arg, error_code ec);
        <a href="#filesystem_error-3-arg">filesystem_error</a>(const string&amp; what_arg,
          const path&amp; p1, error_code ec);
        <a href="#filesystem_error-4-arg">filesystem_error</a>(const string&amp; what_arg,
          const path&amp; p1, const path&amp; p2, error_code ec);

        const path&amp; <a href="#filesystem_error-path1">path1</a>() const noexcept;
        const path&amp; <a href="#filesystem_error-path2">path2</a>() const noexcept;
        const char* <a href="#filesystem_error-what">what</a>() const noexcept;
      };
} } } }  // namespaces std::experimental::filesystem::v1</pre>
<p>The class <code>filesystem_error</code> defines the type of 
objects thrown as exceptions to report file system errors from functions described in this 
Technical Specification.</p>
<h3>9.1  <a name="filesystem_error-members"> <code>filesystem_error</code> members</a> 
[filesystem_error.members]</h3>
<p> Constructors are provided that store zero, one, or two paths associated with 
an error.</p>
<pre><a name="filesystem_error-2-arg">filesystem_error</a>(const string&amp; what_arg, error_code ec);</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%" bgcolor="#FFFFFF"><code>
      runtime_error::what()</code></td>
      <td width="82%" bgcolor="#FFFFFF">
      <code>what_arg.c_str()</code></td>
    </tr>
    <tr>
      <td width="18%"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path1().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path2().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
  </table>
</blockquote>
<pre><a name="filesystem_error-3-arg">filesystem_error</a>(const string&amp; what_arg, const path&amp; p1, error_code ec);</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>
      runtime_error::what()</code></td>
      <td width="82%">
      <code>what_arg.c_str()</code></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>path1()</code></td>
      <td width="82%">Reference to stored copy of <code>p1</code></td>
    </tr>
    <tr>
      <td width="18%" valign="top"><code>path2().empty()</code></td>
      <td width="82%"><code>true</code></td>
    </tr>
  </table>
</blockquote>
<pre><a name="filesystem_error-4-arg">filesystem_error</a>(const string&amp; what_arg, const path&amp; p1, const path&amp; p2, error_code ec);</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="46%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>
      runtime_error::what()</code></td>
      <td width="82%">
      <u>
      <code>w</code></u><code>hat_arg.c_str()</code></td>
    </tr>
    <tr>
      <td width="18%"><code>code()</code></td>
      <td width="82%"><code>ec</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path1()</code></td>
      <td width="82%">Reference to stored copy of <code>p1</code></td>
    </tr>
    <tr>
      <td width="18%"><code>path2()</code></td>
      <td width="82%">Reference to stored copy of <code>p2</code></td>
    </tr>
  </table>
</blockquote>
<pre>const path&amp; <a name="filesystem_error-path1">path1</a>() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> Reference to copy of <code>p1</code> stored by the 
  constructor, or, if none, an empty path.</p>
</blockquote>
<pre>const path&amp; <a name="filesystem_error-path2">path2</a>() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> Reference to copy of <code>p2</code> stored by the 
  constructor, or, if none, an empty path.</p>
</blockquote>
<pre>const char* <a name="filesystem_error-what">what</a>() const noexcept;</pre>
<blockquote>
  <p><i>Returns: </i>A string containing <code>runtime_error::what()</code>. The exact format is unspecified. 
  Implementations are encouraged but not required to include <code>path1.native_string()</code>if not empty, <code>path2.native_string()</code>if 
  not empty, and <code>system_error::what()</code> strings in the returned 
  string.</p>
</blockquote>
<h2>10  Enumerations&nbsp; [<a name="fs.enum">fs.enum</a>]</h2>
<h3>10.1  <a name="Enum-file_type">Enum class <code>file_type</code></a> [enum.file_type]</h3>
<p>This enum class specifies constants used to identify file types.</p>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td><b>Constant Name</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td align="center"><code>0</code></td>
    <td>The type of the file has not been determined or an error occurred while 
    trying to determine the type. </td>
  </tr>
  <tr>
    <td><code>not_found</code></td>
    <td align="center"><code>-1</code></td>
    <td>Pseudo-type indicating the file was not found. [<i>Note:</i> The file 
    not being found is not considered an error while determining the 
    type of a file. <i>&mdash;end note</i>]</td>
  </tr>
  <tr>
    <td><code>regular</code></td>
    <td align="center"><code>1</code></td>
    <td>Regular file</td>
  </tr>
  <tr>
    <td><code>directory</code></td>
    <td align="center"><code>2</code></td>
    <td>Directory file</td>
  </tr>
  <tr>
    <td><code>symlink</code></td>
    <td align="center"><code>3</code></td>
    <td>Symbolic link file</td>
  </tr>
  <tr>
    <td><code>block</code></td>
    <td align="center"><code>4</code></td>
    <td>Block special file</td>
  </tr>
  <tr>
    <td><code>character</code></td>
    <td align="center"><code>5</code></td>
    <td>Character special file</td>
  </tr>
  <tr>
    <td><code>fifo</code></td>
    <td align="center"><code>6</code></td>
    <td>FIFO or pipe file</td>
  </tr>
  <tr>
    <td><code>socket</code></td>
    <td align="center"><code>7</code></td>
    <td>Socket file</td>
  </tr>
  <tr>
    <td><code>unknown</code></td>
    <td align="center"><code>8</code></td>
    <td>The file does exist, but is of an operating system dependent type not 
    covered by any of the other cases or the process does not have permission to 
    query the file type</td>
  </tr>
</table>
<h3>10.2  Enum class <code>copy_options</code> [<a name="enum.copy_options">enum.copy_options</a>]</h3>
<p>The <tt>enum class</tt> type <tt>copy_options</tt> 
is a bitmask type (C++11 §17.5.2.1.3) that specifies bitmask constants used to control the semantics of 
copy operations.&nbsp; The constants are specified in option groups. Constant
<code>none</code> is shown in each option group for purposes of exposition; 
implementations shall provide only a single definition.&nbsp; Calling a 
Filesystem library function with more than a single constant for an option 
group results in undefined behavior.</p>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td colspan="3">
    <p align="center"><b>Option group controlling <code>copy_file</code> 
    function effects for existing target files</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td align="center"><code>0</code></td>
    <td>(Default) Error; file already exists.</td>
  </tr>
  <tr>
    <td><code>skip_existing</code></td>
    <td align="center"><code>1</code></td>
    <td>Do not overwrite existing file, do not report an error.</td>
  </tr>
  <tr>
    <td><code>overwrite_existing</code></td>
    <td align="center"><code>2</code></td>
    <td>Overwrite the existing file.</td>
  </tr>
  <tr>
    <td><code>update_existing</code></td>
    <td align="center"><code>4</code></td>
    <td>Overwrite the existing file if it is older than the replacement file.</td>
  </tr>
  <tr>
    <td colspan="3">
    <p align="center"><b>Option group controlling <code>copy</code> function effects for 
    sub-directories</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td align="center"><code>0</code></td>
    <td>(Default) Do not copy sub-directories.</td>
  </tr>
  <tr>
    <td><code>recursive</code></td>
    <td align="center"><code>8</code></td>
    <td>Recursively copy sub-directories and their contents.</td>
  </tr>
  <tr>
    <td colspan="3">
    <p align="center"><b>Option group controlling <code>copy</code> function effects for 
    symbolic links</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td>
    <p align="center"><code>0</code></td>
    <td>(Default) Follow symbolic links.</td>
  </tr>
  <tr>
    <td><code>copy_symlinks</code></td>
    <td>
    <p align="center"><code>16</code></td>
    <td>Copy symbolic links as symbolic links rather than copying the files that 
    they point to.</td>
  </tr>
  <tr>
    <td><code>skip_symlinks</code></td>
    <td>
    <p align="center"><code>32</code></td>
    <td>Ignore symbolic links.</td>
  </tr>
  <tr>
    <td colspan="3">
    <p align="center"><b>Option group controlling <code>copy</code> function effects for
    choosing the form of copying</b></td>
  </tr>
  <tr>
    <td><b>Constant</b></td>
    <td><b>Value</b></td>
    <td><b>Meaning</b></td>
  </tr>
  <tr>
    <td><code>none</code></td>
    <td>
    <p align="center"><code>0</code></td>
    <td>(Default) Copy content.</td>
  </tr>
  <tr>
    <td><code>directories_only</code></td>
    <td>
    <p align="center"><code>64</code></td>
    <td>Copy directory structure only, do not copy non-directory files.</td>
  </tr>
  <tr>
    <td><code>create_symlinks</code></td>
    <td>
    <p align="center"><code>128</code></td>
    <td>Make symbolic links instead of copies of files. The source path shall be 
    an absolute path unless the destination path is in the current directory.</td>
  </tr>
  <tr>
    <td><code>create_hard_links</code></td>
    <td>
    <p align="center"><code>256</code></td>
    <td>Make hard links instead of copies of files.</td>
  </tr>
</table>
<h3>10.3  Enum class <code>perms</code> [<a name="enum.perms">enum.perms</a>]</h3>
<p>The <tt>enum class</tt> type <tt>perms</tt> 
is a bitmask type (C++11 §17.5.2.1.3) that specifies bitmask constants used to identify file 
permissions. <i><span style="background-color: #E0E0E0">POSIX&nbsp; specifies actual values, and those values have been adopted here because 
they are very familiar and ingrained for many  users.</span></i></p>
<table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
  <tr>
    <td><b>Name</b></td>
    <td align="center"><b>Value<br>
    (octal)</b></td>
    <td align="center"><b>POSIX<br>
    macro</b></td>
    <td><b>Definition or notes</b></td>
  </tr>

<tr><td>
  <p><code>none</code></td><td><code>0</code></td><td></td>
  <td>There are no permissions set for the file.</td>
</tr>
<tr><td><code>owner_read</code></td><td><code>0400</code></td><td> <code>S_IRUSR</code></td>
  <td> Read permission, owner</td>
</tr>
<tr><td><code>owner_write</code></td><td><code>0200</code></td><td> <code>S_IWUSR</code></td>
  <td> Write permission, owner</td>
</tr>
<tr><td><code>owner_exec</code></td><td><code>0100</code></td><td>  <code>S_IXUSR</code></td>
  <td> Execute/search permission, owner</td>
</tr>
<tr><td><code>owner_all</code></td><td><code>0700</code></td><td>  <code>S_IRWXU</code></td>
  <td> Read, write, execute/search by owner; <code>owner_read | owner_write | owner_exec</code></td>
</tr>
<tr><td><code>group_read</code></td><td><code>040</code></td><td>  <code>S_IRGRP</code></td>
  <td> Read permission, group</td>
</tr>
<tr><td><code>group_write</code></td><td><code>020</code></td><td> <code>S_IWGRP</code></td>
  <td> Write permission, group</td>
</tr>
<tr><td><code>group_exec</code></td><td><code>010</code></td><td>   <code>S_IXGRP</code></td>
  <td> Execute/search permission, group</td>
</tr>
<tr><td><code>group_all</code></td><td><code>070</code></td><td>   <code>S_IRWXG</code></td>
  <td> Read, write, execute/search by group; <code>group_read | group_write | group_exec</code></td>
</tr>
<tr><td><code>others_read</code></td><td><code>04</code></td><td>  <code>S_IROTH</code></td>
  <td> Read permission, others</td>
</tr>
<tr><td><code>others_write</code></td><td><code>02</code></td><td> <code>S_IWOTH</code></td>
  <td> Write permission, others</td>
</tr>
<tr><td><code>others_exec</code></td><td><code>01</code></td><td>   <code>S_IXOTH</code></td>
  <td> Execute/search permission, others</td>
</tr>
<tr><td><code>others_all</code></td><td><code>07</code></td><td>   <code>S_IRWXO</code></td>
  <td>Read, write, execute/search by others; <code>others_read | others_write | others_exec</code></td>
</tr>
<tr><td><code>all</code></td><td><code>0777</code></td><td> </td><td><code>owner_all | group_all | others_all</code></td>
</tr>
<tr><td><code>set_uid</code></td><td><code>04000</code></td><td> <code>S_ISUID</code></td>
  <td> Set-user-ID on execution</td>
</tr>
<tr><td><code>set_gid</code></td><td><code>02000</code></td><td> <code>S_ISGID</code></td>
  <td> Set-group-ID on execution</td>
</tr>
<tr><td><code><a name="sticky_bit">sticky_bit</a> </code></td><td><code>01000</code></td><td> <code>S_ISVTX</code></td>
  <td> Operating system dependent.</td>
</tr>
<tr><td><code><a name="perms_mask">mask</a></code></td><td><code>07777</code></td><td> &nbsp;</td>
  <td><code>all | set_uid | set_gid | sticky_bit</code></td>
</tr>
<tr><td><code>unknown</code></td><td><code>0xFFFF</code></td><td></td><td> 
  The permissions are not known, such as when a <code>file_status</code> object 
  is created without specifying the permissions</td>
</tr>
<tr><td><code><a name="symlink_perms">add_perms</a></code></td><td><code>0x10000</code></td><td>&nbsp;</td><td>
  <code>permissions()</code> shall bitwise <i>or</i> the <code>perm</code> argument&#39;s permission bits to the 
  file's current permission bits.</td>
</tr>

<tr><td><code><a name="symlink_perms">remove_perms</a></code></td><td><code>
  0x20000</code></td><td>&nbsp;</td><td>
  <code>permissions()</code> shall bitwise <i>and</i> the complement of
    <code>perm</code> argument&#39;s permission bits to the 
  file's current permission bits.</td>
</tr>

<tr><td><code><a name="symlink_perms">resolve_symlinks</a></code></td><td><code>
  0x40000</code></td><td>&nbsp;</td><td>
  <code>permissions()</code> shall resolve symlinks</td>
</tr>

</table>
<p><i><span style="background-color: #E0E0E0">Windows: All permissions except 
write are currently ignored. There is only a single write permission; setting 
write permission for owner, group, or others sets write permission for all, and 
removing write permission for owner, group, or others removes write permission 
for all. The Cygwin users guide has extensive discussion of the problems 
involved. Input from security experts is needed.</span></i></p>
<h2>11  <a name="file_status">Class <code>file_status</code></a> [class.file_status]</h2>
<pre>namespace std { namespace experimental { namespace filesystem { inline namespace v1 {

      class file_status
      {
      public:

        // <a href="#file_status-constructors">constructors</a>
        explicit file_status(<a href="#file_type">file_type</a> ft = file_type::none,
                             <a href="#Enum.perms">perms</a> prms = perms::unknown) noexcept;
        file_status(const file_status&amp;) noexcept = default;
        file_status(file_status&amp;&amp;) noexcept = default;
       ~file_status();

        file_status&amp; operator=(const file_status&amp;) noexcept = default;
        file_status&amp; operator=(file_status&amp;&amp;) noexcept = default;

        // <a href="#file_status-observers">observers</a>
        <a href="#file_type">file_type</a>  type() const noexcept;
        <a href="#Enum.perms">perms</a>      permissions() const noexcept;

        // <a href="#file_status-modifiers">modifiers</a>
        void       type(<a href="#file_type">file_type</a> ft) noexcept;
        void       permissions(<a href="#Enum.perms">perms</a> prms) noexcept;
      };
} } } }  // namespaces std::experimental::filesystem::v1</pre>
<p>An object of type <code>file_status</code> stores information about the type 
and permissions of a file.</p>
<h3>11.1  <a name="file_status-constructors"><code>file_status</code> constructors</a> 
[file_status.cons]</h3>
<pre>explicit file_status() noexcept;</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>type() == file_type::none</code>, <code>permissions() == perms::unknown</code>.</p>
</blockquote>
<pre>explicit file_status(<a href="#file_type">file_type</a> ft, <a href="#Enum.perms">perms</a> prms = perms::unknown) noexcept;</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>type() == ft</code>, <code>permissions() == prms</code>.</p>
</blockquote>
  <h3>11.2  <a name="file_status-observers"><code>file_status</code> observers</a> [file_status.obs]</h3>
<pre><a href="#file_type">file_type</a> type() const noexcept;</pre>
<blockquote>
  <p><i>Returns: </i>The value of <code>type()</code> specified by the <i>postconditions</i> of the most recent call to a constructor, operator=, or <code>type(file_type)</code> function.</p>
</blockquote>
<pre><a href="#Enum.perms">perms</a> permissions() const noexcept;</pre>
<blockquote>
  <p><i>Returns: </i>The value of <code>permissions()</code> specified by the <i>postconditions</i> of the most recent call to a constructor, operator=, or <code>permissions(perms)</code> function.</p>
</blockquote>
<h3>11.3  <a name="file_status-modifiers"><code>file_status</code> modifiers</a> [file_status.mods]</h3>
<pre>void type(<a href="#file_type">file_type</a> ft) noexcept;</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>type() == ft</code>.</p>
</blockquote>
<pre>void permissions(<a href="#Enum.perms">perms</a> prms) noexcept;</pre>
<blockquote>
  <p><i>Postconditions:</i> <code>permissions() == prms</code>.</p>
</blockquote>
<h2>12  <a name="Class-directory_entry">Class <code>directory_entry</code></a> [class.directory_entry]</h2>
<pre>namespace std { namespace experimental { namespace filesystem { inline namespace v1 {

      class directory_entry
      {
      public:

        // <a href="#directory_entry-constructors">constructors</a> and destructor
        directory_entry() = default;
        directory_entry(const directory_entry&amp;) = default;
        directory_entry(directory_entry&amp;&amp;) noexcept = default;
        explicit directory_entry(const path&amp; p, file_status st=file_status(),
          file_status symlink_st=file_status());
       ~directory_entry(); 

        // <a href="#directory_entry-modifiers">modifiers</a>
        directory_entry&amp; operator=(const directory_entry&amp;) = default;
        directory_entry&amp; operator=(directory_entry&amp;&amp;) noexcept = default;
        void assign(const path&amp; p, file_status st=file_status(),
          file_status symlink_st=file_status());
        void replace_filename(const path&amp; p, file_status st=file_status(),
          file_status symlink_st=file_status());

        // <a href="#directory_entry-observers">observers</a>
        const path&amp;  path() const noexcept;
        file_status  status() const;
        file_status  status(error_code&amp; ec) const noexcept;
        file_status  symlink_status() const;
        file_status  symlink_status(error_code&amp; ec) const noexcept;

        bool operator&lt; (const directory_entry&amp; rhs) const noexcept;
        bool operator==(const directory_entry&amp; rhs) const noexcept; 
        bool operator!=(const directory_entry&amp; rhs) const noexcept; 
        bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;
        bool operator&gt; (const directory_entry&amp; rhs) const noexcept;
        bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;
      private:
        path                 m_path;           // for exposition only
        mutable file_status  m_status;         // for exposition only; stat()-like
        mutable file_status  m_symlink_status; // for exposition only; lstat()-like
      };

} } } }  // namespaces std::experimental::filesystem::v1</pre>
<p>A <code>directory_entry</code> object stores a <code>path object</code>, 
a <code>file_status</code> object for non-symbolic link status, and a <code>file_status</code> object for symbolic link status.
The <code>file_status</code> objects act as value caches.</p>
<blockquote>
<p>[<i>Note:</i> Because <code>status()</code>on a pathname may be a relatively expensive operation, 
some operating systems provide status information as a byproduct of directory 
iteration. Caching such status information can result in significant time savings. Cached and 
non-cached results may differ in the presence of file system races. <i>&mdash;end note</i>]</p>
</blockquote>
<h3>12.1  <a name="directory_entry-constructors"><code>directory_entry</code> constructors</a> 
[directory_entry.cons]</h3>
<pre>explicit directory_entry(const path&amp; p, file_status st=file_status(),
                         file_status symlink_st=file_status());</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="36%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>path()</code></td>
      <td width="82%"><code>p</code></td>
    </tr>
    <tr>
      <td width="18%"><code>status()</code></td>
      <td width="82%"><code>st</code></td>
    </tr>
    <tr>
      <td width="18%"><code>symlink_status()</code></td>
      <td width="82%"><code>symlink_st</code></td>
    </tr>
  </table>
</blockquote>
<h3>12.2  <a name="directory_entry-modifiers"><code>directory_entry</code> modifiers</a> 
[directory_entry.mods]</h3>
<pre>void assign(const path&amp; p, file_status st=file_status(),
            file_status symlink_st=file_status());</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="36%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>path()</code></td>
      <td width="82%"><code>p</code></td>
    </tr>
    <tr>
      <td width="18%"><code>status()</code></td>
      <td width="82%"><code>st</code></td>
    </tr>
    <tr>
      <td width="18%"><code>symlink_status()</code></td>
      <td width="82%"><code>symlink_st</code></td>
    </tr>
  </table>
</blockquote>
<pre>void replace_filename(const path&amp; p, file_status st=file_status(),
                      file_status symlink_st=file_status());</pre>
<blockquote>
  <p><i>Postcondition:</i></p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="43%">
    <tr>
      <td width="18%"><b>Expression</b></td>
      <td width="82%"><b>Value</b></td>
    </tr>
    <tr>
      <td width="18%"><code>path()</code></td>
      <td width="82%"><code>path().parent_path() / p</code></td>
    </tr>
    <tr>
      <td width="18%"><code>status()</code></td>
      <td width="82%"><code>st</code></td>
    </tr>
    <tr>
      <td width="18%"><code>symlink_status()</code></td>
      <td width="82%"><code>symlink_st</code></td>
    </tr>
  </table>
</blockquote>
<h3>12.3  <a name="directory_entry-observers"><code>directory_entry</code> observers</a> 
[directory_entry.obs]</h3>
<pre>const path&amp; path() const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path</code></p>
</blockquote>
<pre>file_status status() const;
file_status status(error_code&amp; ec) const noexcept;</pre>
<blockquote>
<p><i>Effects:</i> As if,</p>
  <blockquote>
    <pre>if (!status_known(m_status))
{
  if (status_known(m_symlink_status) &amp;&amp; !is_symlink(m_symlink_status))
    { m_status = m_symlink_status; }
  else { m_status = status(m_path<i>[, ec]</i>); }
}</pre>
  </blockquote>
  <p><i>Returns:</i> <code>m_status</code></p>
  
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  
</blockquote>
<pre>file_status  symlink_status() const;
file_status  symlink_status(error_code&amp; ec) const noexcept;</pre>
<blockquote>
<p>
  <i>Effects:</i> As if,</p>
  <blockquote>
    <pre>if (!status_known(m_symlink_status))
{
  m_symlink_status = symlink_status(m_path<i>[, ec]</i>);
}</pre>
  </blockquote>
  <p><i>Returns:</i> <code>m_symlink_status</code></p>
  
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  
</blockquote>
<pre>bool operator==(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path == rhs.m_path</code>.</p>
  <p>[<i>Note:</i> Status members do not participate in determining 
  equality. — end note] </p>
</blockquote>
<pre>bool operator!=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path != rhs.m_path</code>.</p>
</blockquote>
<pre>bool operator&lt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &lt; rhs.m_path</code>.</p>
</blockquote>
<pre>bool operator&lt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &lt;= rhs.m_path</code>.</p>
</blockquote>
<pre>bool operator&gt; (const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &gt; rhs.m_path</code>.</p>
</blockquote>
<pre>bool operator&gt;=(const directory_entry&amp; rhs) const noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>m_path &gt;= rhs.m_path</code>.</p>
</blockquote>
<h2>13  <a name="Class-directory_iterator">Class <code>directory_iterator</code> 
[class.directory_iterator]</a></h2>
<p>An object of type <code>directory_iterator</code> provides an iterator for a 
sequence of <code>directory_entry</code> elements representing the files in a 
directory.&nbsp; 
[<i>Note:</i> For iteration into sub-directories,&nbsp; see class <code><a href="#Class-recursive_directory_iterator">recursive_directory_iterator</a></code> 
([class.rec.dir.itr]). <i>&mdash;end note</i>]</p>

<pre>namespace std { namespace experimental { namespace filesystem { inline namespace v1 {

      class directory_iterator
      {
      public:
        typedef directory_entry        value_type;
        typedef ptrdiff_t              difference_type;
        typedef const directory_entry* pointer;
        typedef const directory_entry&amp; reference;
        typedef input_iterator_tag     iterator_category;

        // <a href="#directory_iterator-members">member functions</a>
        directory_iterator() noexcept;
        explicit directory_iterator(const path&amp; p);
        directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
        directory_iterator(const directory_iterator&amp;) = default;
        directory_iterator(directory_iterator&amp;&amp;) = default;
       ~directory_iterator();

        directory_iterator&amp; operator=(const directory_iterator&amp;) = default;
        directory_iterator&amp; operator=(directory_iterator&amp;&amp;) = default;

        const directory_entry&amp; operator*() const;
        const directory_entry* operator-&gt;() const;
        directory_iterator&amp;    operator++();
        directory_iterator&amp;    increment(error_code&amp; ec) noexcept;

        // other members as required by
        //  C++11 § 24.1.1 Input iterators 
      };

} } } }  // namespaces std::experimental::filesystem::v1</pre>

<p> <code>directory_iterator</code> satisfies the requirements of an input 
iterator&nbsp; C++11 §24.2.3).</p>
<p>If an iterator of type <code>directory_iterator</code> is advanced past the 
last directory element, that iterator shall become equal to the end iterator 
value. The <code>directory_iterator</code> default constructor&nbsp;shall 
create an iterator equal to the end iterator value, and this shall be the only 
valid iterator for the end condition. </p>
<p>The result of <code>operator*</code> on an end iterator is undefined behavior. For any other iterator value 
a <code>const directory_entry&amp;</code> is returned. The result of <code>operator-&gt;</code> on an end iterator is 
undefined behavior. For any other iterator value a <code>const directory_entry*</code> is 
returned.</p>
<p>Two end iterators are always equal. An end iterator shall not be equal to a non-end 
iterator.</p>
<blockquote>
<p><i><span style="background-color: #E0E0E0">The above wording is based on the 
Standard Library's istream_iterator wording.</span></i></p>
</blockquote>
<p>The result of calling the <code>path()</code> member of the <code>directory_entry</code> object obtained by dereferencing a <code>directory_iterator</code> is a reference to a <code>path</code> object composed of the directory argument from which the iterator was 
constructed with filename of the directory entry appended as if by <code>operator/=</code>. </p>
<p>Directory iteration shall not yield directory entries for the current (<i>dot</i>) 
and parent (<i>dot-dot</i>) directories.</p>
<p>The order of directory entries obtained by dereferencing successive 
increments of a <code>directory_iterator</code> is unspecified.</p>
<blockquote>
<p>[<i>Note:</i> Programs performing directory iteration may wish to test if the 
path obtained by dereferencing a directory iterator actually exists. It could be 
a
symbolic link to a non-existent file. Programs recursively 
walking directory trees for purposes of removing and renaming entries may wish 
to avoid following symbolic links.</p>
<p>If a file  is removed from or added to a directory after the 
construction of a <code>directory_iterator</code> for the directory, it is 
unspecified whether or not subsequently incrementing the iterator will ever 
result in an iterator referencing the removed or added directory entry. See 
POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/readdir_r.html">readdir_r()</a></code>. <i>&mdash;end note</i>]</p>
</blockquote>
<h3>13.1  <a name="directory_iterator-members"><code>directory_iterator</code> members</a> 
[directory_iterator.members]</h3>

<p><code><a name="directory_iterator-default-ctor">directory_iterator</a>() 
noexcept;</code></p>

<blockquote>

<p><i>Effects:</i> Constructs the end iterator.</p>

</blockquote>

<pre><code>explicit <a name="directory_iterator-ctor-path">directory_iterator</a>(</code>const path&amp; p<code>);
directory_iterator(</code>const path&amp; p, error_code&amp; ec<code>) noexcept;</code></pre>
<blockquote>

<p><i>Effects:</i> For the directory that <code>p</code> resolves to, constructs an 
iterator for the first element in a sequence of <code>directory_entry</code> 
elements representing the files in the directory, if any; otherwise the end iterator.</p>

<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>

<p>[<i>Note:</i> To iterate over the current directory, use <code>directory_iterator(&quot;.&quot;)</code> rather than <code>directory_iterator(&quot;&quot;)</code>. <i>&mdash;end note</i>]</p>
</blockquote>
<pre>directory_iterator&amp; <a name="directory_iterator-increment">operator++</a>();
directory_iterator&amp; increment(error_code&amp; ec)<code> noexcept</code>;</pre>
<blockquote>

<p><i>Effects:</i> As specified by C++11 §24.1.1 Input iterators.</p>

<p><i>Returns:</i> <code>*this</code>.</p>

<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>

</blockquote>
<h3>13.2  <a name="directory_iterator-non-member-functions"><code>directory_iterator</code> non-member functions</a> 
[directory_iterator.nonmembers]</h3>
<p>These functions enable use of <code>directory_iterator</code> with 
range-based for statements.</p>
<pre>directory_iterator begin(directory_iterator iter) noexcept;</pre>
<blockquote>
  <p><i>Returns: </i><code>iter</code>.</p>
</blockquote>
<pre>directory_iterator end(const directory_iterator&amp;) noexcept;</pre>
<blockquote>
  <p><i>Returns: </i><code>directory_iterator()</code>.</p>
</blockquote>
<h2>14  <a name="Class-recursive_directory_iterator">Class <code>recursive_directory_iterator</code> 
[class.rec.dir.itr]</a></h2>
<p>An object of type <code>recursive_directory_iterator</code> provides an iterator for 
a sequence of <code>directory_entry</code> elements representing the files in a 
directory and its sub-directories.</p>
<pre>namespace std { namespace experimental { namespace filesystem { inline namespace v1 {

      class recursive_directory_iterator 
      {
      public:
        typedef directory_entry        value_type;
        typedef ptrdiff_t              difference_type;
        typedef const directory_entry* pointer;
        typedef const directory_entry&amp; reference;
        typedef input_iterator_tag     iterator_category;

        // constructors and destructor
        recursive_directory_iterator() noexcept;
        recursive_directory_iterator(const recursive_directory_iterator&amp;) = default;
        explicit recursive_directory_iterator(const path&amp; p,
          <a href="#symlink_option">directory_options</a> options = directory_options::none);
        recursive_directory_iterator(const path&amp; p,
          <a href="#symlink_option">directory_options</a> options, error_code&amp; ec) noexcept;
        recursive_directory_iterator(const path&amp; p, error_code&amp; ec) noexcept;
        recursive_directory_iterator(recursive_directory_iterator&amp;&amp;) = default;
       ~recursive_directory_iterator();

        // observers
        directory_options  options() const;
        int                depth() const;
        bool               recursion<code>_pending</code>() const;

        // modifiers
        recursive_directory_iterator&amp; operator=(const recursive_directory_iterator&amp;) = default;
        recursive_directory_iterator&amp; operator=(recursive_directory_iterator&amp;&amp;) = default;

        const directory_entry&amp; operator*() const;
        const directory_entry* operator-&gt;() const;

        recursive_directory_iterator&amp; operator++();
        recursive_directory_iterator&amp; increment(error_code&amp; ec);

        void pop();
        void disable_recursion_pending();

       // other members as required by C++11 § 24.1.1 Input iterators
      
     };

} } } }  // namespaces std::experimental::filesystem::v1</pre>

<p>The behavior of a <code>recursive_directory_iterator</code> is the same 
as a <code>directory_iterator</code> unless otherwise specified.</p>

<p><ins>[<i>Note: </i>If the directory structure being iterated over contains cycles 
then the end iterator may be unreachable. <i>&mdash;end note</i>]</ins></p>
<h3>14.1  <code><a name="recursive_directory_iterator-members">recursive_directory_iterator</a></code> members 
[<a name="rec.dir.itr.members">rec.dir.itr.members</a>]</h3>

<pre>recursive_directory_iterator() noexcept;</pre>
<blockquote>

<p><i>Effects:</i> Constructs the end iterator.</p>

</blockquote>

<pre>explicit recursive_directory_iterator(const path&amp; p,
  <a href="#symlink_option">directory_options</a> options = directory_options::none);
recursive_directory_iterator(const path&amp; p, <a href="#symlink_option">directory_options</a> options, error_code&amp; ec) noexcept;
recursive_<code>directory_iterator(</code>const path&amp; p, error_code&amp; ec<code>) noexcept;</code></pre>
<blockquote>

<p><i>Effects:</i>&nbsp; Constructs a iterator representing the first 
entry in the directory <code>p</code> resolves to, if any; otherwise, the end iterator.</p>

<p><i>Postcondition: </i><code>options() == options</code> for the signatures with a <code>
directory_options</code> argument, otherwise <code>options() == 
directory_options::none</code>.</p>

<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>

<p>[<i>Note:</i> To iterate over the current directory, use <code>recursive_directory_iterator(&quot;.&quot;)</code> rather than <code>recursive_directory_iterator(&quot;&quot;)</code>. <i>&mdash;end note</i>]</p>

<p>[<i>Note:</i> By default, <code>recursive_directory_iterator</code> does not 
follow directory symlinks. To follow directory symlinks, specify <code>options</code> as <code>
directory_options::follow_directory_symlink</code> <i>&mdash;end note</i>]</p>
</blockquote>
<pre>directory_options options() const;</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
<p><i>Returns:</i> The value of the constructor <code>options</code> argument, 
if present, otherwise <code>directory_options::none</code>.</p>
<p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre>int depth() const;</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p><i>Returns:</i> The current depth of the directory tree being traversed. [<i>Note:</i> 
  The initial directory is depth 0, its immediate subdirectories are depth 1, 
  and so forth. <i>&mdash;end note</i>]</p>
<p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre>bool <code>recursion_pending</code>() const;</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p><i>Returns:</i> <code>true</code> if <code>disable_recursion_pending()</code> 
  has not been called subsequent to the prior construction or increment 
  operation, otherwise <code>false</code>.</p>
  <p><i>Throws:</i> Nothing.</p>
</blockquote>
<pre><code>recursive_directory_iterator</code>&amp; <a name="recursive_directory_iterator-increment">operator++</a>();
recursive_directory_iterator&amp; increment(error_code&amp; ec);</pre>
<blockquote>

  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>

<p><i>Effects:</i> As specified by C++11 § 
 24.1.1 Input iterators, 
except that:</p>

<ul>
  <li>

<p>If there are no more  entries at this depth, then if <code>depth()!= 0</code> 
iteration over the parent directory resumes; otherwise <code>*this = recursive_directory_iterator()</code>.</p>

  </li>
  <li>

<p>Otherwise if <code>recursion_pending() &amp;&amp; is_directory(this-&gt;status()) 
&amp;&amp; (!is_symlink(this-&gt;symlink_status()) || (options() &amp; 
directory_options::follow_directory_symlink) != 0)</code> then&nbsp;directory <code>(*this)-&gt;path()</code> is recursively iterated into.</p>

  </li>
</ul>

<p><i>Returns:</i> <code>*this</code>.</p>

<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>

</blockquote>
<pre>void pop();</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
  <p><i>Effects:</i> If <code>depth() == 0</code>, set <code>*this</code> to <code>recursive_directory_iterator()</code>. 
  Otherwise, cease iteration of the directory currently being 
  iterated over, and continue iteration over the parent directory.</p>
</blockquote>
<pre>void disable_recursion_pending();</pre>
<blockquote>
  <p><i>Requires:</i> <code>*this != recursive_directory_iterator()</code>.</p>
<p><i>Postcondition:</i> <code>recursion_pending() == false</code>.</p>
  <p>[<i>Note:</i> <code>disable_recursion_pending</code><code>()</code> is used to prevent 
  unwanted recursion into a directory. <i>&mdash;end note</i>]</p>
</blockquote>
<h3>14.2  <code>recursive_directory_iterator</code> non-member functions 
[<a name="rec.dir.itr.nonmembers">rec.dir.itr.nonmembers</a>]</h3>
<p>These functions enable use of <code>recursive_directory_iterator</code> 
with range-based for statements.</p>
<pre>recursive_directory_iterator begin(recursive_directory_iterator iter) noexcept;</pre>
<blockquote>
  <p><i>Returns: </i><code>iter</code>.</p>
</blockquote>
<pre>recursive_directory_iterator end(const recursive_directory_iterator&amp;) noexcept;</pre>
<blockquote>
  <p><i>Returns: </i><code>recursive_directory_iterator()</code>.</p>
</blockquote>
<h2>15  <a name="Operational-functions">Operational functions</a> [fs.op.funcs]</h2>
<p>Operational functions query or modify files, including directories, in external 
storage.</p>
<p>[<i>Note: </i>Because hardware failures, network failures, <a href="#file-system-race">file system races</a>, and many 
other kinds of errors occur frequently in file system operations, users should be aware 
that any filesystem operational function, no matter how apparently innocuous, may encounter 
an error.&nbsp;See <a href="#Error-reporting">Error reporting (7)</a>. <i>&mdash;end note</i>]</p>
<h3>15.1  Absolute&nbsp; [<a name="fs.op.absolute">fs.op.absolute</a>]</h3>
<pre>path <a name="absolute">absolute</a>(const path&amp; p, const path&amp; base=current_path());</pre>
  <blockquote>
  <p><i>Returns:</i> An <a href="#Absolute-path">absolute path</a> composed according to the 
  following table</p>
  <table border="1" cellpadding="5" cellspacing="0" bordercolor="#111111" style="border-collapse: collapse">
    <tr>
      <td align="center">&nbsp;</td>
      <td align="center"><b><code>p.has_root_directory()</code></b></td>
      <td align="center"><b><code>!p.has_root_directory()</code></b></td>
    </tr>
    <tr>
      <td align="center"><b><code>p.has_root_name()</code></b></td>
      <td align="center"><code>return p</code></td>
      <td align="center"><code>return p.root_name() / absolute(base).root_directory()<br>
      / absolute(base).relative_path() / p.relative_path()</code></td>
    </tr>
    <tr>
      <td align="center"><b><code>!p.has_root_name()</code></b></td>
      <td align="center"><code>return absolute(base).root_name()<br>
      / p</code></td>
      <td align="center"><code>return absolute(base) / p</code></td>
    </tr>
  </table>
  <p>[<i>Note:</i> For the returned path, <code>rp,</code> <code>rp.is_absolute()</code> is true. <i>&mdash;end note</i>]</p>
  <p><i>Throws:</i> If <code>base.is_absolute()</code> is true, throws only if 
  memory allocation fails.</p>
</blockquote>
<h3>15.2  Canonical&nbsp; [<a name="fs.op.canonical">fs.op.canonical</a>]</h3>
<pre>path <a name="canonical">canonical</a>(const path&amp; p, const path&amp; base = current_path());
path canonical(const path&amp; p, error_code&amp; ec);
path canonical(const path&amp; p, const path&amp; base, error_code&amp; ec);</pre>
<blockquote>
<p><i>Overview:</i> Converts <code>p</code>, which must exist, to an absolute 
path that has no symbolic link, <code>&quot;.&quot;</code>, 
or <code>&quot;..&quot;</code> elements. </p>
<p><i>Returns:</i> A path that refers to 
the same file system object as <code>absolute(p,base)</code>. For the overload 
without a <code>base</code> argument, <code>base</code> is <code>current_path()</code>. 
Signatures with argument <code>ec</code> return <code>path()</code> if an error occurs.</p>
  <p><i>Throws:</i>&nbsp; As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  
  <p><i>Remarks:</i> <code>!exists(p)</code> is an error.</p>
  
  <p>[<i>Note:</i> Canonical pathnames allow security checking of a path (e.g. 
  does this path live in /home/goodguy or /home/badguy?)&nbsp; <i>&mdash;end note</i>]</p>
  
</blockquote>
<h3>15.3  Copy&nbsp; [<a name="fs.op.copy">fs.op.copy</a>]</h3>
<pre>void <a name="copy">copy</a>(const path&amp; from, const path&amp; to);
void copy(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects: </i><code>copy(from, to, copy_options::none<i>[, ec]</i>)</code>.</p>
  
</blockquote>

<pre>void <a name="copy2">copy</a>(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> options);
void copy(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> options, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Precondition:</i> At most one constant from each option group ([<a href="#enum.copy_options">enum.copy_options</a>]) 
  is present in <code>options</code>.</p>
  <p><i>Effects:</i></p>
  
  <blockquote>
  <p>Before the first use of <code>f</code> and <code>t</code>:</p>
  
    <ul>
      <li>If <code>(options &amp; copy_options::create_symlinks) || (options &amp; 
      copy_options::skip_symlinks)</code>, then <code>auto f = 
      symlink_status(from)</code> and if needed <code>auto t = symlink_status(to)</code>.</li>
      <li>Otherwise, <code>auto f = status(from)</code> and if needed <code>auto 
      t = status(to)</code>.</li>
    </ul>
  <p>Report an error as specified in <a href="#Error-reporting">Error reporting (7)</a> 
  if:</p>
  
    <ul>
      <li><code>!exists(f)</code>, or</li>
      <li><code>equivalent(from, to)</code>, or</li>
      <li><code>is_other(f) || is_other(t)</code>, or</li>
      <li><code>is_directory(f) &amp;&amp; is_regular_file(t)</code>.</li>
    </ul>
  <p>If <code>is_symlink(f)</code>, then:</p>
  
    <ul>
      <li>If <code>options &amp; copy_options::skip_symlinks</code>, then return.</li>
      <li>Otherwise if <code>!exists(t)</code>, then <code>copy_symlink(from, 
      to, options)</code>.</li>
      <li>Otherwise report an error as specified in <a href="#Error-reporting">Error reporting (7)</a>.</li>
    </ul>
  <p>Otherwise if <code>is_regular_file(f)</code>, then:</p>
  
    <ul>
      <li>If <code>options &amp; copy_options::directories_only</code>, then return.</li>
      <li>Otherwise if <code>options &amp; copy_options::create_symlinks</code>, then 
      create a symbolic link to the source file.</li>
      <li>Otherwise if <code>options &amp; copy_options::create_hard_links</code>, 
      then create a hard link to the source file.</li>
      <li>Otherwise if <code>is_directory(t)</code>, then <code>copy_file(from, to/from.filename(), 
        options)</code>.</li>
      <li>Otherwise, <code>copy_file(from, to, options)</code>.</li>
    </ul>
  </blockquote>
</blockquote>
<blockquote>
  <blockquote>
  <p>Otherwise if <code>is_directory(f) &amp;&amp; ((options &amp; 
  copy_options::recursive) || !(options))</code> 
  then:</p>
  
    <ul>
      <li>If&nbsp; <code>!exists(t)</code>, then <code>create_directory(to, 
      from)</code>.</li>
      <li>Then, iterate over the files in <code>from</code>, as if by <code>for 
      (directory_entry&amp; x : directory_iterator(from))</code>, and for each 
      iteration <code>copy(x.path(), to/x.path().filename(), options | 
      copy_options::<i>unspecified</i>)</code>.</li>
    </ul>
  <p>Otherwise no effects.</p>
  
  </blockquote>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  
  <p><i>Remarks: </i>For the signature with argument <code>ec</code>, any 
  Filesystem library functions called by the implementation shall have an <code>
  error_code</code> argument if applicable. </p>
  
  <p>[<i>Example:</i> Given this directory structure:</p>
  
  <pre>/dir1
  file1
  file2
  dir2
    file3</pre>
  <p>Calling <code>copy(&quot;/dir1&quot;, &quot;/dir3&quot;)</code> would result in: </p>
  <pre>/dir1
  file1
  file2
  dir2
    file3
/dir3
  file1
  file2
</pre>
  <p>Alternatively, calling <code>copy(&quot;/dir1&quot;, &quot;/dir3&quot;, 
  copy_options::recursive)</code> would result in: </p>
  
  <pre>/dir1
  file1
  file2
  dir2
    file3  
/dir3
  file1
  file2
  dir2
    file3</pre>

<p><i>&mdash;end example</i>]</p>
  
</blockquote>

<h3>15.4  Copy file&nbsp; [<a name="fs.op.copy_file">fs.op.copy_file</a>]</h3>
<pre>bool copy_file(const path&amp; from, const path&amp; to);
bool copy_file(const path&amp; from, const path&amp; to, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Returns: </i><code>copy_file(from, to, copy_options::none</code><i>[</i><code>, ec</code><i>]</i><code>)</code>.</p>
  
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  
</blockquote>
<pre>bool <a name="copy_file">copy_file</a>(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> options);
bool <a name="copy_file2">copy_file</a>(const path&amp; from, const path&amp; to, <a href="#copy_option">copy_options</a> options,
               error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Precondition:</i> At most one constant from each <code>copy_options</code> 
  option group ([<a href="#enum.copy_options">enum.copy_options</a>]) is present 
  in <code>options</code>.</p>
  <p><i>Effects:</i> </p>
  <blockquote>
    <p><del>If&nbsp; <code>exists(to) &amp;&amp;</code> <code>!(options &amp; (copy_options::skip_existing 
    | copy_options::overwrite_existing | copy_options::update_existing)) </code>
    report a file already exists error as specified in
    <a href="file:///C:/dot16/filesystem-ts/n4080.html#Error-reporting">Error 
    reporting (7)</a>. </del></p>
    <p><del>If <code>!exists(to) || (options &amp; copy_options::overwrite_existing) 
    || ((options &amp; copy_options::update_existing) &amp;&amp; last_write_time(from) &gt; 
    last_write_time(to)) || !(options &amp; (copy_options::skip_existing | 
    copy_options::overwrite_existing | copy_options::update_existing)) </code>
    copy the contents and attributes of the file <code>from</code> resolves to 
    the file <code>to</code> resolves to. </del></p>
  </blockquote>
  <blockquote>
    <p><ins>Report a file already exists error as specified in
    <a href="file:///C:/dot16/filesystem-ts/working-draft.html#Error-reporting">
    Error reporting (7) </a>if: </ins></p>
    <ul>
      <li><ins><code>exists(to)</code> and <code>equivalent(from, to)</code>, or
      </ins></li>
      <li><ins><code>exists(to)</code> and <code>(options &amp; (copy_options::skip_existing 
      | copy_options::overwrite_existing | copy_options::update_existing)) == 
      copy_options::none. </code></ins></li>
    </ul>
    <p><ins>Otherwise copy the contents and attributes of the file <code>from</code> 
    resolves to to the file <code>to</code> resolves to if: </ins></p>
    <ul>
      <li><ins><code>!exists(to)</code>, or </ins></li>
      <li><ins><code>exists(to)</code> and <code>(options &amp; 
      copy_options::overwrite_existing) != copy_options::none </code>, or </ins>
      </li>
      <li><ins><code>exists(to)</code> and <code>(options &amp; 
      copy_options::update_existing) != copy_options::none </code>and <code>from</code> 
      is more recent than <code>to</code>, determined as if by use of the <code>
      last_write_time </code>function. </ins></li>
    </ul>
    <p><ins>Otherwise no effects.</ins></p>
  </blockquote>
  <p><i>Returns</i>: <code>true</code> if the <code>from</code> file 
  was copied, otherwise <code>false</code>. The signature with argument <code>ec</code> return
  <code>false</code> if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  <p><i>Complexity:</i> At most one direct or indirect invocation of <code>
  status(to)</code>.</p>
</blockquote>
<h3>15.5  Copy symlink&nbsp; [<a name="fs.op.copy_symlink">fs.op.copy_symlink</a>]</h3>
<pre>void <a name="copy_symlink">copy_symlink</a>(const path&amp; existing_symlink, const path&amp; new_symlink);
void copy_symlink(const path&amp; existing_symlink, const path&amp; new_symlink,
                  error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects: </i><code><i>function</i>(read_symlink(existing_symlink</code><i>[</i><code>, ec</code><i>]</i><code>), new_symlink</code><i>[</i><code>, ec</code><i>]</i><code>)</code>, 
  where <i><code>function</code></i> is <code>create_symlink</code> or <code>
  create_directory_symlink</code>, as appropriate.</p>
  
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  
</blockquote>

<h3>15.6  Create directories&nbsp; [<a name="fs.op.create_directories">fs.op.create_directories</a>]</h3>

<pre>bool <a name="create_directories">create_directories</a>(const path&amp; p);
bool <a name="create_directories2">create_directories</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition by calling <code>
  create_directory()</code> for any element of <code>p</code> that does not 
  exist.</p>
  <p><i>Postcondition:</i> <code>is_directory(p)</code></p>
  <p><i>Returns:</i> <code>true</code> if a new directory was created, otherwise <code>
  false</code>. The signature with argument <code>ec</code> returns false if an 
  error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  <p><i>Complexity:</i> <i>O(n+1)</i> where <i>n</i> is the number of elements 
  of <code>p</code> that do not exist.</p>
</blockquote>

<h3>15.7  Create directory&nbsp; [<a name="fs.op.create_directory">fs.op.create_directory</a>]</h3>

<pre>bool <a name="create_directory">create_directory</a>(const path&amp; p);
bool create_directory(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition by attempting to create the 
  directory <code>p</code> resolves to, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/mkdir.html">
  mkdir()</a></code> with a second argument of S_IRWXU|S_IRWXG|S_IRWXO. Creation 
  failure because <code>p</code> resolves to an existing directory shall not be 
  treated as an error. </p>
  <p><i>Postcondition:</i> <code>is_directory(p)</code></p>
  <p><i>Returns:</i> <code>true</code> if a new directory was created, otherwise <code>false</code>. 
  The signature with argument <code>ec</code> returns false if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<pre>bool <a name="create_directory2">create_directory</a>(const path&amp; p, const path&amp; existing_p);
bool create_directory(const path&amp; p, const path&amp; existing_p, error_code&amp; ec) noexcept;</pre>
<blockquote>

  <p><i>Effects: </i>Establishes the postcondition by attempting to create the 
  directory <code>p</code> resolves to, with 
  attributes copied from directory <code>existing_p</code>. The set of attributes 
  copied is operating system dependent. Creation failure because <code>p</code> resolves to an existing directory shall not be 
  treated as an error. </p>
  
<blockquote>
[<i>Note:</i> For POSIX based operating systems the 
      attributes are those copied by native API <code>stat(existing_p.c_str(), &amp;attributes_stat)</code> 
      followed by <code>mkdir(p.c_str(), attributes_stat.st_mode)</code>.&nbsp; For 
      Windows based operating systems the attributes are those copied by native 
      API <code>CreateDirectoryExW(existing_p.c_str(), p.c_str(), 0)</code>.&nbsp; <i>
      &mdash;end note</i>]
</blockquote>
  
  <p><i>Postcondition:</i> <code>is_directory(p)</code></p>
  <p><i>Returns:</i> <code>true</code> if a new directory was created, otherwise <code>false</code>. 
  The signature with argument <code>ec</code> returns false if an error occurs.</p>
  
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>

</blockquote>

<h3>15.8  Create directory symlink&nbsp; [<a name="fs.op.create_dir_symlk">fs.op.create_dir_symlk</a>]</h3>

<pre>void <a name="create_directory_symlink">create_directory_symlink</a>(const path&amp; to, const path&amp; new_symlink);
void create_directory_symlink(const path&amp; to, const path&amp; new_symlink,
                              error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/symlink.html">symlink()</a></code>.</p>
  <p><i>
  Postcondition:</i> <code>new_symlink</code> resolves to a symbolic link file that 
  contains an unspecified representation of <code>to</code>.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  <p>[<i>Note:</i> Some operating systems require symlink creation to 
  identify that the link is to a directory. Portable code should use <code>create_directory_symlink()</code> to create directory symlinks rather than <code>create_symlink()</code> <i>&mdash;end note</i>]</p>
  <p>[<i>Note:</i> Some operating systems do not support symbolic links at all or support 
  them only for regular files. 
  Some file systems do not 
  support 
  symbolic links regardless of the operating system - the FAT file system used on 
  memory cards and flash drives, for example. <i>&mdash;end note</i>]</p>
  </blockquote>

<h3>15.9  Create hard link&nbsp; [<a name="fs.op.create_hard_lk">fs.op.create_hard_lk</a>]</h3>

<pre>void <a name="create_hard_link">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link);
void <a name="create_hard_link2">create_hard_link</a>(const path&amp; to, const path&amp; new_hard_link,
                                      error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/link.html">link()</a></code>.</p>
  <p><i>Postcondition:</i></p>
  <ul>
    <li>&nbsp;<code>exists(to) &amp;&amp; 
    exists(</code><code>new_hard_link</code><code>) &amp;&amp; equivalent(to, 
     
    </code><code>new_hard_link</code><code>)</code></li>
    <li>The contents of the file or directory
    <code>to</code> resolves to are unchanged.</li>
  </ul>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  <p>[<i>Note:</i> Some operating systems do not support hard links at all or support 
  them only for regular files. Some file systems do not support hard 
  links regardless of the operating system - the FAT file system used on memory 
  cards and flash drives, for example. Some file systems limit the number of 
  links per file. <i>&mdash;end note</i>]</p>
  </blockquote>

<h3>15.10  Create symlink&nbsp; [<a name="fs.op.create_symlink">fs.op.create_symlink</a>]</h3>

<pre>void <a name="create_symlink">create_symlink</a>(const path&amp; to, const path&amp; new_symlink);
void <a name="create_symlink2">create_symlink</a>(const path&amp; to, const path&amp; new_symlink,
                    error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/symlink.html">symlink()</a></code>.</p>
  <p><i>
  Postcondition:</i> <code>new_symlink</code> resolves to a symbolic link file that 
  contains an unspecified representation of <code>to</code>.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  <p>[<i>Note:</i> Some operating systems do not support symbolic links at all or support 
  them only for regular files. 
  Some file systems do not 
  support 
  symbolic links regardless of the operating system - the FAT system used on 
  memory cards and flash drives, for example. <i>&mdash;end note</i>]</p>
  </blockquote>

<h3>15.11  Current path&nbsp; [<a name="fs.op.current_path">fs.op.current_path</a>]</h3>

<pre>path <a name="current_path">current_path</a>();
path <a name="current_path2">current_path</a>(error_code&amp; ec);</pre>
<blockquote>
  <p><i>Returns:</i> The absolute path of the current working directory, 
  obtained as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/getcwd.html">getcwd()</a></code>. 
  The signature with argument <code>ec</code> returns <code>path()</code> if an 
  error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  <p><i>Remarks: </i>The current working directory is the directory, associated 
  with the process, that is used as the starting location in pathname resolution 
  for relative paths.</p>
  <p>[<i>Note: </i>The <code>current_path()</code> name was chosen to emphasize that the return is a 
  path, not just a single directory name.</p>
  <p>The current path as returned by many operating systems is a dangerous 
  global variable. It may be changed unexpectedly by a third-party or system 
  library functions, or by another thread.&nbsp; <i>&mdash;end note</i>]</p>
</blockquote>

<pre>void current_path(const path&amp; p);
void current_path(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Establishes the postcondition, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/chdir.html">chdir()</a></code>.</p>
<p><i>Postcondition:</i> <code>equivalent(p, current_path())</code>.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  <p>[<i>Note: </i>The current path for many operating systems is a dangerous 
  global state. It may be changed unexpectedly by a third-party or system 
  library functions, or by another thread.&nbsp; <i>&mdash;end note</i>]</p>
</blockquote>

<h3>15.12  Exists&nbsp; [<a name="fs.op.exists">fs.op.exists</a>]</h3>

<pre>bool <a name="exists">exists</a>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>status_known(s) &amp;&amp; s.type() != 
  file_type::not_found</code></p>
</blockquote>
<pre>bool <a name="exists2">exists</a>(const path&amp; p);
bool <a name="exists3">exists</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>exists(status(p))</code> or <code>exists(status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.13  Equivalent&nbsp; [<a name="fs.op.equivalent">fs.op.equivalent</a>]</h3>

<pre><code>bool <a name="equivalent">equivalent</a>(const path&amp; p1, const path&amp; p2);
bool <a name="equivalent2">equivalent</a>(const path&amp; p1, const path&amp; p2, error_code&amp; ec)</code> noexcept<code>;</code></pre>
<blockquote>
  <p><i>Effects:</i> Determines <code>file_status s1</code> and <code>s2</code>, as if by <code>status(p1)</code> and&nbsp; <code>status(p2)</code>, 
  respectively.</p>
  <p><i>Returns:</i> <code>true</code>, if <code><del>sf1</del> <ins>s1</ins> == 
  <del>sf2</del> <ins>s2</ins></code> and <code>p1</code> and <code>p2</code> resolve to the same file 
  system entity, else <code>false</code>. The signature with argument <code>ec</code> 
  returns <code>false</code> if an error occurs.</p>
  <blockquote>
  <p>Two paths are considered to resolve to the same file system entity if two 
  candidate entities reside on the same device at the same location. This is 
  determined as if by the values of the POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code> structure<code>,</code> obtained as if by <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code> for the two paths, having equal <code>st_dev</code> values 
  and equal <code>st_ino</code> values.</p>
  <p><i><span style="background-color: #E0E0E0">[Note: POSIX requires that &quot;st_dev 
  must be unique within a Local Area Network&quot;. Conservative POSIX implementations may also wish to check for equal <code>st_size</code> and <code>st_mtime</code> values. Windows implementations may use <code>GetFileInformationByHandle()</code> as a surrogate for <code>stat()</code>, 
  and consider &quot;same&quot; to be equal values for <code>dwVolumeSerialNumber</code>, <code>nFileIndexHigh</code>, <code>nFileIndexLow</code>, <code>nFileSizeHigh</code>, <code>nFileSizeLow</code>, <code>ftLastWriteTime.dwLowDateTime</code>, and <code>ftLastWriteTime.dwHighDateTime</code>. &mdash;end note]</span></i></p>
  </blockquote>
  <p><i>Throws:</i> <code>filesystem_error</code> if <code>(!exists(s1) &amp;&amp; !exists(s2)) || (is_other(s1) &amp;&amp; is_other(s2))</code>, 
  otherwise as specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.14  File size&nbsp; [<a name="fs.op.file_size">fs.op.file_size</a>]</h3>

<pre>uintmax_t <a name="file_size">file_size</a>(const path&amp; p);
uintmax_t <a name="file_size2">file_size</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> If <code><ins>!</ins>exists(p) <del>&amp;&amp;</del> <ins>|| !</ins>is_regular_file(p)</code><ins> 
  an error is reported (7). Otherwise</ins>, the size in bytes of the file <code>
  p</code> resolves to, determined as if by the value of the POSIX <code>stat</code> 
  structure member <code>st_size</code> obtained as if by POSIX <code>stat()</code>.
  <del>Otherwise, <code>static_cast&lt;uintmax_t&gt;(-1)</code>.</del> The signature 
  with argument <code>ec</code> returns <code>static_cast&lt;uintmax_t&gt;(-1)</code> 
  if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.15  Hard link count&nbsp; [<a name="fs.op.hard_lk_ct">fs.op.hard_lk_ct</a>]</h3>

<pre>uintmax_t <a name="hard_link_count">hard_link_count</a>(const path&amp; p);
uintmax_t hard_link_count(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>

  <p><i>Returns:</i> The number of hard links for <code>p</code>. The signature 
  with argument <code>ec</code> returns <code>static_cast&lt;uintmax_t&gt;(-1)</code> 
  if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>

</blockquote>

<h3>15.16  Is block file&nbsp; [<a name="fs.op.is_block_file">fs.op.is_block_file</a>]</h3>

<pre>bool <code><a name="is_block_file">is_block_file</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::block</code></p>
</blockquote>

<pre><code>bool is_block_file(const path&amp; p);
bool is_block_file</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_block_file(status(p))</code> or <code>
  is_block_file(status(p, ec))</code>, respectively. The signature with argument <code>
  ec</code> returns <code>false</code> if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>


<h3>15.17  Is character file&nbsp; [<a name="fs.op.is_char_file">fs.op.is_char_file</a>]</h3>

<pre>bool <code><a name="is_character_file">is_character_file</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::character</code></p>
</blockquote>
<pre><code>bool is_character_file</a>(const path&amp; p);
bool is_character_file</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_character_file(status(p))</code> 
  or <code>is_character_file(status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.18  Is directory&nbsp; [<a name="fs.op.is_directory">fs.op.is_directory</a>]</h3>

<pre>bool <code><a name="is_directory">is_directory</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::directory</code></p>
</blockquote>
<pre><code>bool <a name="is_directory2">is_directory</a>(const path&amp; p);
bool <a name="is_directory3">is_directory</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_directory(status(p))</code> or <code>
  is_directory(status(p, ec))</code>, respectively. The signature with argument <code>
  ec</code> returns <code>false</code> if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.19  Is empty&nbsp; [<a name="fs.op.is_empty">fs.op.is_empty</a>]</h3>

<pre><code>bool <a name="is_empty">is_empty</a>(const path&amp; p);
bool <a name="is_empty2">is_empty</a></a>(const path&amp; p, error_code&amp; ec)</code> noexcept<code>;</code></pre>
<blockquote>
  <p><i>Effects:</i> Determines <code>file_status s</code>, as if by <code>status(p, ec)</code>.</p>
  <p><i>Returns:</i> <code>is_directory(s)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? directory_iterator(p) == directory_iterator()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : file_size(p) == 0;</code></p>
  <blockquote>
  <p>The signature with argument <code>ec</code> returns <code>false</code> if 
  an error occurs.</p>
  </blockquote>

<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.20  Is fifo&nbsp; [<a name="fs.op.is_fifo">fs.op.is_fifo</a>]</h3>

<pre>bool <code><a name="is_fifo">is_fifo</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::fifo</code></p>
</blockquote>

<pre><code>bool is_fifo(const path&amp; p);
bool is_fifo(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_fifo(status(p))</code> or <code>is_fifo(status(p, 
  ec))</code>, respectively. The signature with argument <code>ec</code> returns <code>
  false</code> if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.21  Is other&nbsp; [<a name="fs.op.is_other">fs.op.is_other</a>]</h3>

<pre>bool <a name="is_other">is_other</a>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>return exists(s) &amp;&amp; !is_regular_file(s) &amp;&amp; !is_directory(s) &amp;&amp; !is_symlink(s)</code></p>
</blockquote>
<pre><code>bool <a name="is_other2">is_other</a>(const path&amp; p);
bool <a name="is_other3">is_other</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_other(status(p))</code> or <code>is_other(status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.22  Is regular file&nbsp; [<a name="fs.op.is_regular_file">fs.op.is_regular_file</a>]</h3>

<pre>bool <code><a name="is_regular_file">is_regular_file</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::regular</code>.</p>
</blockquote>
<pre><code>bool <a name="is_regular_file2">is_regular_file</a>(const path&amp; p);</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_regular_file(status(p))</code>.</p>
  <p><i>Throws:</i> <code>filesystem_error</code> if <code>status(p)</code> would throw <code>filesystem_error.</code></p>
  </blockquote>
<pre><code>bool <a name="is_regular_file3">is_regular_file</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Effects:</i> Sets <code>ec</code> as if by <code>status(p, ec)</code>. [<i>Note:</i> <code>
  file_type::none</code>, <code>file_type::not_found</code> and <code>
  file_type::unknown</code> cases set <code>ec</code> to error values. To distinguish between cases, call the <code>status</code> function directly. <i>&mdash;end 
  note</i>] </p>
  <p><i>Returns:</i> <code>is_regular_file(status(p, ec))</code>. Returns <code>
  false</code> if an error occurs.</p>
</blockquote>

<h3>15.23  Is socket&nbsp; [<a name="fs.op.is_socket">fs.op.is_socket</a>]</h3>

<pre>bool <code><a name="is_socket">is_socket</a></code>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::socket</code></p>
</blockquote>
<pre><code>bool is_socket(const path&amp; p);
bool is_socket(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_socket(status(p))</code> or <code>
  is_socket(status(p, ec))</code>, respectively. The signature with argument <code>
  ec</code> returns <code>false</code> if an error occurs.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.24  Is symlink&nbsp; [<a name="fs.op.is_symlink">fs.op.is_symlink</a>]</h3>

<pre>bool <a name="is_symlink">is_symlink</a>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() == file_type::symlink</code></p>
</blockquote>
<pre><code>bool <a name="is_symlink2">is_symlink</a>(const path&amp; p);
bool <a name="is_symlink3">is_symlink</a>(const path&amp; p, error_code&amp; ec) noexcept;</code></pre>
<blockquote>
  <p><i>Returns:</i> <code>is_symlink(symlink_status(p))</code> or <code>is_symlink(symlink_status(p, ec))</code>, 
  respectively. The signature with argument <code>ec</code> returns <code>false</code> 
  if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.25  Last write time&nbsp; [<a name="fs.op.last_write_time">fs.op.last_write_time</a>]</h3>

<pre>file_time_type <a name="last_write_time">last_write_time</a>(const path&amp; p);
file_time_type <a name="last_write_time2">last_write_time</a>(const path&amp; p<code>, error_code&amp; ec</code>) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> The time of last data modification of <code>p</code>, 
  determined as if by the value of the POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">stat</a></code> structure member <code>st_mtime</code>&nbsp; 
  obtained as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>. 
  The signature with argument <code>ec</code> returns <tt>file_time_type::min()</tt> 
  if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>
<pre>void <a name="last_write_time3">last_write_time</a>(const path&amp; p, file_time_type new_time);
void <a name="last_write_time4">last_write_time</a>(const path&amp; p, file_time_type new_time<code>,
                     error_code&amp; ec</code>) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Sets the time of last data modification of the file 
  resolved to by <code>p</code> to <code>new_time</code>, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code> 
  followed by POSIX <a href="http://www.opengroup.org/onlinepubs/000095399/functions/utime.html"><code>utime()</code></a>.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  <p>[<i>Note:</i> A postcondition of <code>last_write_time(p) == new_time</code> is not specified since it might not hold for file systems 
  with coarse time granularity. <i>&mdash;end note</i>]</p>
</blockquote>

<h3>15.26  Permissions&nbsp; [<a name="fs.op.permissions">fs.op.permissions</a>]</h3>

<pre>void <a name="permissions">permissions</a>(const path&amp; p, <a href="#symlink_perms">perms</a> prms);
void permissions(const path&amp; p, <a href="#symlink_perms">perms</a> prms, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p>
  <i>Requires:</i> <code>!((prms &amp; add_perms) &amp;&amp; (prms &amp; remove_perms))</code>.</p>
  <p><i>Effects:</i> Applies the effective permissions bits from <code>prms</code> to the file <code>p</code> 
  resolves to, as if by POSIX <code><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html">fchmodat()</a></code>. The effective permission bits are determined as 
  specified by the following table. </p>
  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td><b>bits present in <code>prms</code></b></td>
      <td><b>Effective bits applied</b></td>
    </tr>
    <tr>
      <td>Neither <code>add_perms</code> nor <code>remove_perms</code></td>
      <td><code>prms &amp; perms::mask</code></td>
    </tr>
    <tr>
      <td><code>add_perms</code></td>
      <td>
      <p><code>status(p).permissions() | (prms &amp; <a href="#perms_mask">perms::mask</a>)</code> </td>
    </tr>
    <tr>
      <td><code>remove_perms</code></td>
      <td><code>status(p)</code><code>.permissions() &amp; ~(prms &amp; <a href="#perms_mask">perms::mask</a>) </code></td>
    </tr>
  </table>
  <p>[<i>Note:</i> Conceptually permissions are viewed as bits, but the actual 
  implementation may use some other mechanism. -- <i>end note</i>]</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.27  Read symlink&nbsp; [<a name="fs.op.read_symlink">fs.op.read_symlink</a>]</h3>

<pre>path <a name="read_symlink">read_symlink</a>(const path&amp; p);
path read_symlink(const path&amp; p, error_code&amp; ec);</pre>
<blockquote>
  <p><i>Returns:</i>&nbsp; If <code>p</code> resolves to a symbolic 
  link, a <code>path</code> object containing the contents of that symbolic 
  link. The signature with argument <code>ec</code> 
  returns <code>path()</code> if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>. [<i>Note:</i> It is an error if <code>p</code> does not 
  resolve to a symbolic link. <i>&mdash;end note</i>]</p>
</blockquote>

<h3>15.28  Remove&nbsp; [<a name="fs.op.remove">fs.op.remove</a>]</h3>

<pre>bool <a name="remove">remove</a>(const path&amp; p);
bool <a name="remove2">remove</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i>&nbsp; If <code>exists(symlink_status(p,ec))</code>, it is 
  removed as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/remove.html">remove()</a></code>.</p>
  <blockquote>
  <p>[<i>Note:</i> A symbolic link is itself removed, rather than the file it 
  resolves to being removed. <i>&mdash;end note</i>]</p>
  </blockquote>
  <p><i>Postcondition:</i> <code>!exists(symlink_status(p))</code>.</p>
  <p><i>Returns:</i>&nbsp; <code>false</code> if p did not exist in the first 
  place, otherwise <code>true</code>. The signature with argument <code>ec</code> 
  returns <code>false</code> if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.29  Remove all&nbsp; [<a name="fs.op.remove_all">fs.op.remove_all</a>]</h3>

<pre>uintmax_t <a name="remove_all">remove_all</a>(const path&amp; p);
uintmax_t <a name="remove_all2">remove_all</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i>&nbsp; Recursively deletes the contents of p if it exists, 
  then deletes file <code>p</code> itself, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/remove.html">remove()</a></code>.</p>
  <blockquote>
  <p>[<i>Note:</i> A symbolic link is itself removed, rather than the file it 
  resolves to being removed. <i>&mdash;end note</i>]</p>
  </blockquote>
  <p><i>Postcondition:</i> <code>!exists(p)</code></p>
  <p><i>Returns:</i> The number of files removed. The signature with argument
  <code>ec</code> returns <code>static_cast&lt;uintmax_t&gt;(-1)</code> if an error 
  occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.30  Rename&nbsp; [<a name="fs.op.rename">fs.op.rename</a>]</h3>

<pre>void <a name="rename">rename</a>(const path&amp; old_p, const path&amp; new_p);
void <a name="rename2">rename</a>(const path&amp; old_p, const path&amp; new_p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i> Renames <code>old_p</code> to <code>new_p</code>, as if by 
  POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/rename.html">rename()</a></code>.</p>
  <blockquote>
  <p>[<i>Note:</i> If <code>old_p</code> and <code>new_p</code> resolve to the 
  same existing file, no action is taken. Otherwise, if <code>new_p</code> resolves to an 
  existing non-directory file, it is removed, while if <code>new_p</code> 
  resolves to an existing directory, it is removed if empty on POSIX compliant operating 
  systems but is an error on some other operating systems. A symbolic link is itself renamed, rather than 
  the file it resolves to being renamed. <i>&mdash;end note</i>]</p>
  </blockquote>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.31  Resize file&nbsp; [<a name="fs.op.resize_file">fs.op.resize_file</a>]</h3>

<pre>void <a name="resize_file">resize_file</a>(const path&amp; p, uintmax_t new_size);
void <a name="resize_file2">resize_file</a>(const path&amp; p, uintmax_t new_size, error_code&amp; ec) noexcept;</pre>
<blockquote>
<p><i>Postcondition:</i> <code>file_size() == new_size</code>.</p>
<p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  <p><i>Remarks:</i> Achieves its postconditions as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/truncate.html">truncate()</a></code>.</p>
</blockquote>

<h3>15.32  Space&nbsp; [<a name="fs.op.space">fs.op.space</a>]</h3>

<pre>space_info <a name="space">space</a>(const path&amp; p);
space_info <a name="space2">space</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> An object of type <code><a href="#space_info">space_info</a></code>. The value of the <code>space_info</code> 
  object is determined as if by using POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/statvfs.html"
   style="text-decoration: none">statvfs()</a></code> to obtain a POSIX struct
  <code><a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/statvfs.h.html" style="text-decoration: none">statvfs</a></code>,
   and then multiplying its <code>f_blocks</code>, <code>f_bfree</code>,
   and <code>f_bavail</code> members by its <code>f_frsize</code> member,
   and assigning the results to the <code>capacity</code>, <code>free</code>, 
  and <code>available</code> members respectively. Any members for which the 
  value cannot be determined shall be set to <code>static_cast&lt;uintmax_t&gt;(-1)</code>. 
  For the signature with argument <code>ec</code>, all members are set to <code>
  static_cast&lt;uintmax_t&gt;(-1)</code> if an error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
      <p><i>Remarks:</i> The value of member <code>space_info::available</code> 
      is operating system dependent. [<i>Note:</i> <code>available</code> may be 
      less than <code>free</code>. <i>— end note</i>] </p>
</blockquote>

<h3>15.33  Status&nbsp; [<a name="fs.op.status">fs.op.status</a>]</h3>

<pre><a href="#file_status">file_status</a> <a name="status">status</a>(const path&amp; p);</pre>
<blockquote>
  <p><i>Effects: </i>As if:</p>
  <blockquote>
    <pre>error_code ec;
file_status result = status(p, ec);
if (result == file_type::none)
  throw filesystem_error(<i>implementation-supplied-message</i>, p, ec);
return result;</pre>
  </blockquote>
  <p><i>Returns:</i> See above.</p>
  <p><i>Throws:</i> <code>filesystem_error</code>. 
[<i>Note:</i> <code>result</code> values of <code>
  file_status(file_type::not_found)</code> 
  and <code>file_status(file_type::unknown)</code> are not considered failures and do not 
  cause an exception to be 
thrown.<i> &mdash;end note</i>] </p>
  </blockquote>
<pre><a href="#file_status">file_status</a> <a name="status2">status</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects: </i></p>
  <blockquote>
    <p>If possible, determines the attributes 
    of the file <code>p</code> resolves to, as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/stat.html">stat()</a></code>.</p>
      If, during attribute determination, the underlying file system API reports 
    an error, sets <code>ec</code> to indicate the specific error reported. 
    Otherwise, <code>ec.clear()</code>.<blockquote>
      <p>[<i>Note:</i> This allows users to inspect the specifics of underlying 
      API errors even when the value returned by <code>status()</code> is not <code>
      file_status(file_type::none)</code>.&nbsp; <i>&mdash;end note</i>]</p>
    </blockquote>
    </blockquote>
  <p><i>Returns:</i></p>
  <blockquote>
    <p>If <code>ec != error_code()</code>:</p>
    <ul>
      <li>If the specific error indicates that <code>p</code> cannot be resolved 
      because some element of the path does not exist, return <code>
      file_status(file_type::not_found)</code>.<span style="font-style: italic; background-color: #E0E0E0"> </span><i><span style="background-color: #E0E0E0">
      POSIX errors that 
      indicate this are </span><span style="background-color: #E0E0E0">ENOENT</span><span style="background-color: #E0E0E0"> or 
      </span><span style="background-color: #E0E0E0">ENOTDIR</span><span style="background-color: #E0E0E0">. Windows equivalents 
      include </span><span style="background-color: #E0E0E0">
      ERROR_FILE_NOT_FOUND</span><span style="background-color: #E0E0E0">, 
      </span><span style="background-color: #E0E0E0">ERROR_PATH_NOT_FOUND</span><span style="background-color: #E0E0E0">, 
      </span><span style="background-color: #E0E0E0">ERROR_INVALID_NAME</span><span style="background-color: #E0E0E0">, 
      </span><span style="background-color: #E0E0E0">ERROR_INVALID_PARAMETER</span><span style="background-color: #E0E0E0">, 
      </span><span style="background-color: #E0E0E0">ERROR_BAD_PATHNAME</span><span style="background-color: #E0E0E0">, and 
      </span><span style="background-color: #E0E0E0">ERROR_BAD_NETPATH</span><span style="background-color: #E0E0E0">.</span></i><br>
&nbsp;</li>
      <li>Otherwise, if the specific error indicates that <code>p</code> can be resolved 
      but the attributes cannot be determined, return <code>
      file_status(file_type::unknown)</code>. <i><span style="background-color: #E0E0E0">For example, Windows 
      </span><span style="background-color: #E0E0E0">ERROR_SHARING_VIOLATION</span><span style="background-color: #E0E0E0"> 
      errors. For POSIX, the case never arises.</span></i><br>
&nbsp;</li>
      <li>Otherwise, return <code>
      file_status(file_type::none)</code>.</li>
    </ul>
        <blockquote>
        <p>[<i>Note:</i> These semantics distinguish between <code>p</code> being known not to exist, <code>p</code> existing but not being able to determine its attributes, 
        and there being an error that prevents even knowing if <code>p</code> exists. These 
        distinctions are important to some use cases.&nbsp;<i>&mdash;end note</i>]</p>
    </blockquote>
    <p>Otherwise,</p>
    <ul>
      <li>If the attributes indicate a regular file, as if by POSIX&nbsp;<a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISREG()</a>, 
      return <code>
      file_status(file_type::regular)</code>. [<i>Note:</i> <code>
      file_type::regular</code> implies appropriate <code>&lt;fstream&gt;</code> operations 
      would succeed, assuming no hardware, permission, access, or file system 
      race 
      errors. Lack of
<code>file_type::regular</code> does not necessarily imply <code>&lt;fstream&gt;</code> operations would 
fail on a directory.
<i>&mdash;end note</i>]<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a directory, as if by POSIX
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISDIR()</a>, 
      return <code>
      file_status(file_type::directory)</code>. [<i>Note:</i> <code>
      file_type::directory</code> implies <code>
directory_iterator(p)</code>would succeed.
<i>&mdash;end note</i>]<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a block special file, as if by 
      POSIX
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISBLK()</a>, 
      return <code>
      file_status(file_type::block)</code>.<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a character special file, as if 
      by POSIX
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISCHR()</a>, 
      return <code>
      file_status(file_type::character)</code>.<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a fifo or pipe file, as if by 
      POSIX
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISFIFO()</a>, 
      return <code>
      file_status(file_type::fifo)</code>.<br>
&nbsp;</li>
      <li>Otherwise, if the attributes indicate a socket, as if by POSIX
      <a href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISSOCK()</a>, 
      return <code>
      file_status(file_type::socket)</code>.<br>
&nbsp;</li>
      <li>Otherwise, return <code>
      file_status(file_type::unknown)</code>.</li>
    </ul>
    </blockquote>
      <p><i>Remarks:</i> If a symbolic link is encountered during pathname 
      resolution, 
      pathname resolution continues using the contents of the symbolic link.</p>
</blockquote>

<h3>15.34  Status known&nbsp; [<a name="fs.op.status_known">fs.op.status_known</a>]</h3>

<pre>bool <a name="status_known">status_known</a>(file_status s) noexcept;</pre>
<blockquote>
  <p><i>Returns:</i> <code>s.type() != file_type::none</code></p>
</blockquote>

<h3>15.35  Symlink status&nbsp; [<a name="fs.op.symlink_status">fs.op.symlink_status</a>]</h3>

<pre>file_status <a name="symlink_status">symlink_status</a>(const path&amp; p);
file_status <a name="symlink_status2">symlink_status</a>(const path&amp; p, error_code&amp; ec) noexcept;</pre>
<blockquote>
  <p><i>Effects:</i>&nbsp; Same as <a href="#status">status()</a>, above, 
  except that the attributes 
    of <code>p</code> are determined as if by POSIX <code><a href="http://www.opengroup.org/onlinepubs/000095399/functions/lstat.html">lstat()</a></code>.</p>
</blockquote>
<blockquote>
      <p><i>Returns:</i> Same as <a href="#status">status()</a>, above, except 
      that if the attributes indicate a symbolic link, as if by POSIX <a class="external" href="http://www.opengroup.org/onlinepubs/000095399/basedefs/sys/stat.h.html">S_ISLNK()</a>, return <code>
      file_status(file_type::symlink)</code>. 
      The signature with argument <code>ec</code> returns <code>
      file_status(file_type::none)</code> if an error occurs.</p>
      <p><i>Remarks:</i> Pathname resolution terminates if <code>p</code> names a symbolic link.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
</blockquote>

<h3>15.36  System complete&nbsp; [<a name="fs.op.system_complete">fs.op.system_complete</a>]</h3>

<pre>path <a name="system_complete">system_complete</a>(const path&amp; p);
path <a name="system_complete2">system_complete</a>(const path&amp; p, error_code&amp; ec);</pre>
<blockquote>
  <p><i>Effects:</i> Composes an absolute path from <code>p</code>, using the 
  same rules used by the operating system to resolve a path passed as the 
  filename argument to standard library open functions.</p>
  <p><i>Returns:</i> The composed path. The signature with argument <code>ec</code> 
  returns <code>path()</code> if an error occurs.</p>
  <p><i>Postcondition:</i> For the returned path, <code>rp,</code> <code>rp.is_absolute()</code> is true.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  
<blockquote>
[<i>Example:</i> For POSIX based operating systems, <code>system_complete(p)</code>
  has the same semantics as <code>absolute(p, current_path())</code>.</p>
  <p>For Windows based operating systems, <code>system_complete(p)</code> has the 
  same semantics as <code>absolute(p, current_path())</code> if <code>p.is_absolute() ||
  !p.has_root_name()</code> or <code>p</code> and <code>base</code> have the same
  <code>root_name()</code>. 
  Otherwise it acts like <code>absolute(p, kinky)</code>, where <code>kinky</code> is
  the current directory for the <code>p.root_name()</code> drive. This will 
  be the current directory for that drive the last time it was set, and thus may 
  be <b>residue left over from a prior program</b> run by the command 
  processor! Although these semantics are useful, they are very 
  error-prone. <i>&mdash;end example</i>]
</blockquote>
  
</blockquote>

<h3>15.37  Temporary directory path&nbsp; [<a name="fs.op.temp_dir_path">fs.op.temp_dir_path</a>]</h3>

<pre>path <a name="temp_directory_path">temp_directory_path</a>();
path temp_directory_path(error_code&amp; ec);</pre>
<blockquote>
  <p><i>Returns:</i> An unspecifed directory path suitable for temporary files. An error shall be reported if<code> !exists(p) 
  || !is_directory(p)</code>, where <code>p</code> is the path to be returned. 
  The signature with argument <code>ec</code> returns <code>path()</code> if an 
  error occurs.</p>
  <p><i>Throws:</i> As specified in <a href="#Error-reporting">Error reporting (7)</a>.</p>
  <p><i><span style="background-color: #E0E0E0">The <code>temp_directory_path()</code> 
  name was chosen to emphasize that the return is a path, not just a single 
  directory name.</span></i></p>
<blockquote>
[<i>Example:</i> For POSIX based operating systems, an implementation might 
  return the path 
  supplied by the first environment variable found in the list TMPDIR, TMP, TEMP, TEMPDIR, 
  or if none of these are found, <code>&quot;/tmp&quot;</code>.</p>
  <p>For Windows based operating systems, an implementation might return the path
  reported by the <i>Windows</i> <code>GetTempPath</code> API function.<i> &mdash;end example</i>] </p> 
  
</blockquote>
</blockquote>

<hr>


</body></html>